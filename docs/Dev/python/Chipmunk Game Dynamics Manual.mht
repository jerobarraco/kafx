Content-Type: multipart/related; start=<op.mhtml.1325834541069.18afb2617d46662a@192.168.1.98>; boundary=----------Y47EGPtdbWNKttFrOftBHR
Content-Location: http://chipmunk-physics.net/release/ChipmunkLatest-Docs/
Subject: =?utf-8?Q?Chipmunk=20Game=20Dynamics=20Manual?=
MIME-Version: 1.0

------------Y47EGPtdbWNKttFrOftBHR
Content-Disposition: inline; filename=default.htm
Content-Type: text/html; charset=utf-8; name=default.htm
Content-ID: <op.mhtml.1325834541069.18afb2617d46662a@192.168.1.98>
Content-Location: http://chipmunk-physics.net/release/ChipmunkLatest-Docs/
Content-Transfer-Encoding: Quoted-Printable

	<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3=
.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
	<html xmlns=3D"http://www.w3.org/1999/xhtml" xml:lang=3D"en" lang=3D"en=
">
		<head>
			<meta http-equiv=3D"Content-Type" content=3D"text/html; charset=3Dutf=
-8" />
			<title>Chipmunk Game Dynamics Manual</title>
			<link rel=3D"stylesheet" type=3D"text/css" href=3D"stylesheet.css" />=

		</head>
		<body>
			<script language=3D"javascript">
				function toggleDiv(divid){
					if(document.getElementById(divid).style.display =3D=3D 'none'){
						document.getElementById(divid).style.display =3D 'block';
					}else{
						document.getElementById(divid).style.display =3D 'none';
					}
				}
				=

				function toggleExample(divid, name){
					toggleDiv(divid);
					var div =3D document.getElementById(divid);
					var i =3D div.innerHTML;
					=

					if(div.innerHTML =3D=3D ""){
						div.innerHTML =3D "Loading ..."
						=

						var xmlhttp =3D new XMLHttpRequest();
						xmlhttp.onreadystatechange =3D function(){
							if(xmlhttp.readyState =3D=3D 4){
								div.innerHTML =3D xmlhttp.responseText;
							}
						}
						=

						xmlhttp.open("GET", name, true);
						xmlhttp.send();
					}
				}
			</script>
			=

			<p><img src=3D"images/logo1_med.png" alt=3D"" /> <a href=3D"http://ho=
wlingmoonsoftware.com"><img src=3D"images/hms_logo.png" style=3D"float:r=
ight;" alt=3D"" /></a></p>
<div><a class=3D"HideShow" href=3D"javascript:;" onmousedown=3D"toggleDi=
v('Pop Open Outline');">Hide/Show Outline</a><div class=3D"PopOpen" id=3D=
"Pop Open Outline" style=3D"display:none"><ul><li><a href=3D"#Intro">Chi=
pmunk Physics 6.0.3</a><ul><li><a href=3D"#Intro-WhyC">Why a C Library?<=
/a></li><li><a href=3D"#Intro-Limitations">Limitations of a C <span clas=
s=3D"caps">API</span>:</a></li><li><a href=3D"#Intro-Compiling">Get it, =
Compile it:</a></li><li><a href=3D"#Intro-HelloChipmunk">Hello Chipmunk =
(World)</a></li><li><a href=3D"#Intro-Support">Support:</a></li><li><a h=
ref=3D"#Intro-ContactUS">Contact:</a></li><li><a href=3D"#Intro-License"=
>License:</a></li><li><a href=3D"#Intro-Links">Links:</a></li><p></ul></=
li><li><a href=3D"#Basics">Chipmunk Basics:</a><ul><li><a href=3D"#Basic=
s-Overview">Overview:</a></li><li><a href=3D"#Basics-Memory">Memory Mana=
gement the Chipmunk way:</a></li><li><a href=3D"#Basics-Types">Basic Typ=
es:</a></li><li><a href=3D"#Basics-Math">Math the Chipmunk way:</a></li>=
</ul></li><li><a href=3D"#cpVect">Chipmunk Vectors: <code>cpVect</code><=
/a><ul><li><a href=3D"#cpVect-Basics">Struct Definition, Constants and C=
onstructors:</a></li><li><a href=3D"#cpVect-Operations">Operations:</a><=
/li></ul></li><li><a href=3D"#cpBB">Chipmunk Axis Aligned Bounding Boxes=
: <code>cpBB</code></a><ul><li><a href=3D"#cpBB-Basics">Struct Definitio=
n and Constructors:</a></li><li><a href=3D"#cpBB-Operations">Operations:=
</a></li></ul></li><li><a href=3D"#cpBody">Chipmunk Rigid Bodies: <code>=
cpBody</code></a><ul><li><a href=3D"#cpBody-RougeStatic">Rogue and Stati=
c Bodies:</a></li><li><a href=3D"#cpBody-Memory">Memory Management Funct=
ions:</a></li><li><a href=3D"#cpBody-StaticBodies">Creating Additional S=
tatic Bodies:</a></li><li><a href=3D"#cpBody-Properties">Properties:</a>=
</li><li><a href=3D"#cpBody-Helpers">Moment of Inertia and Area Helper F=
unctions:</a></li><li><a href=3D"#cpBody-CoordinateConversion">Coordinat=
e Conversion Functions:</a></li><li><a href=3D"#cpBody-Forces">Applying =
Forces and Torques:</a></li><li><a href=3D"#cpBody-Sleeping">Sleeping Fu=
nctions:</a></li><li><a href=3D"#cpBody-Iterators">Iterators</a></li><li=
><a href=3D"#cpBody-Integration Callbacks">Integration Callbacks:</a></l=
i><li><a href=3D"#cpBody-Misc">Misc Functions:</a></li><li><a href=3D"#c=
pBody-Notes">Notes:</a></li></ul></li><li><a href=3D"#cpShape">Chipmunk =
Collision Shapes: <code>cpShape</code></a><ul><li><a href=3D"#cpShape-Pr=
operties">Properties:</a></li><li><a href=3D"#cpShape-Filtering">Filteri=
ng Collisions:</a></li><li><a href=3D"#cpShape-Memory">Memory Management=
 Functions:</a></li><li><a href=3D"#cpShape-Misc">Misc Functions:</a></l=
i><li><a href=3D"#cpShape-Circles">Working With Circle Shapes:</a></li><=
li><a href=3D"#cpShape-Segments">Working With Segment Shapes:</a></li><l=
i><a href=3D"#cpShape-Polys">Working With Polygon Shapes:</a></li><li><a=
 href=3D"#cpShape-Modifing">Modifying cpShapes:</a></li><li><a href=3D"#=
cpShape-Notes">Notes:</a></li></ul></li><li><a href=3D"#cpSpace">Chipmun=
k Spaces: <code>cpSpace</code></a><ul><li><a href=3D"#cpSpace-Iterations=
">What Are Iterations, and Why Should I care?</a></li><li><a href=3D"#cp=
Space-Sleeping">Sleeping</a></li><li><a href=3D"#cpSpace-Properties">Pro=
perties:</a></li><li><a href=3D"#cpSpace-Memory">Memory Management Funct=
ions:</a></li><li><a href=3D"#cpSpace-Operations">Operations:</a></li><l=
i><a href=3D"#cpSpace-SpatialIndexing">Spatial Indexing:</a></li><li><a =
href=3D"#cpSpace-Iterators">Iterators:</a></li><li><a href=3D"#cpSpace-S=
imulating">Simulating the Space:</a></li><li><a href=3D"#cpSpace-Spatial=
Hash">Enabling and Tuning the Spatial Hash:</a></li><li><a href=3D"#cpSp=
ace-Notes">Notes:</a></li></ul></li><li><a href=3D"#cpConstraint">Chipmu=
nk Constraints: <code>cpConstraint</code></a><ul><li><a href=3D"#cpConst=
raint-WhatIs">What constraints are and what they are not:</a></li><li><a=
 href=3D"#cpConstraint-Properties">Properties:</a></li><li><a href=3D"#c=
pConstraint-ErrorCorrection">Error correction by Feedback:</a></li><li><=
a href=3D"#cpConstraint-Shapes">Constraints and Collision Shapes:</a></l=
i><li><a href=3D"#cpConstraint-Video">Video Tour of Current Joint Types.=
 (Requires connection to YouTube)</a></li><li><a href=3D"#cpConstraint-M=
emory">Shared Memory Management Functions:</a></li></ul></li><li><a href=
=3D"#ConstraintTypes">Constraint Types:</a><ul><li><a href=3D"#Constrain=
tTypes-cpPinJoint">Pin Joints:</a></li><li><a href=3D"#ConstraintTypes-c=
pSlideJoint">Slide Joints:</a></li><li><a href=3D"#ConstraintTypes-cpPiv=
otJoint">Pivot Joints:</a></li><li><a href=3D"#ConstraintTypes-cpGrooveJ=
oint">Groove Joint:</a></li><li><a href=3D"#ConstraintTypes-cpDampedSpri=
ng">Damped Spring:</a></li><li><a href=3D"#ConstraintTypes-cpDampedRotar=
ySpring">Damped Rotary Spring:</a></li><li><a href=3D"#ConstraintTypes-c=
pRotaryLimitJoint">Rotary Limit Joint:</a></li><li><a href=3D"#Constrain=
tTypes-cpRatchetJoint">Ratchet Joint:</a></li><li><a href=3D"#Constraint=
Types-cpGearJoint">Gear Joint:</a></li><li><a href=3D"#ConstraintTypes-c=
pSimpleMotor">Simple Motor:</a></li><li><a href=3D"#ConstraintTypes-Note=
s">Notes:</a></li></ul></li><li><a href=3D"#CollisionDetection">Overview=
 of Collision Detection in Chipmunk:</a><ul><li><a href=3D"#CollisionDet=
ection-SpatialIndexing">Spatial Indexing:</a></li><li><a href=3D"#Collis=
ionDetection-Filtering">Collision Filtering:</a></li><li><a href=3D"#Col=
lisionDetection-PrimitiveTest">Primitive Shape to Shape Collision Detect=
ion:</a></li><li><a href=3D"#CollisionDetection-HandlerFiltering">Collis=
ion Handler Filtering:</a></li></ul></li><li><a href=3D"#CollisionCallba=
cks">Collision Callbacks:</a><ul><li><a href=3D"#CollisionCallbacks-Hand=
lers">Collision Handlers:</a></li><li><a href=3D"#CollisionCallbacks-Han=
dlerAPI">Collision Handler <span class=3D"caps">API</span>:</a></li><li>=
<a href=3D"#CollisionCallbacks-PostStep">Post-Step Callbacks:</a></li><l=
i><a href=3D"#CollisionCallbacks-Examples">Examples:</a></li></ul></li><=
li><a href=3D"#cpArbiter">Chipmunk Collision Pairs: <code>cpArbiter</cod=
e></a><ul><li><a href=3D"#cpArbiter-Memory">Memory Management:</a></li><=
li><a href=3D"#cpArbiter-Properties">Properties:</a></li><li><a href=3D"=
#cpArbiter-HelperFunctions">Contact Point Sets:</a></li><li><a href=3D"#=
cpArbiter-HelperFunctions">Helper Functions:</a></li></ul></li><li><a hr=
ef=3D"#Queries">Queries:</a><ul><li><a href=3D"#Queries-PointQueries">Po=
int Queries:</a></li><li><a href=3D"#Queries-SegmentQueries">Segment Que=
ries:</a></li><li><a href=3D"#Queries-AABBQueries"><span class=3D"caps">=
AABB</span> Queries:</a></li><li><a href=3D"#Queries-ShapeQueries">Shape=
 Queries:</a></li><li><a href=3D"#Queries-Examples">Examples:</a></li></=
ul></li></ul></div></div></p>
<h1><a name=3D"Intro"></a><a href=3D"#Intro">Chipmunk Physics 6.0.3</a><=
/h1>
<p>First of all, Chipmunk is a 2D rigid body physics library distributed=
 under the <span class=3D"caps">MIT</span> license. It is intended to be=
 blazingly fast, portable, numerically stable, and easy to use. For this=
 reason it&#8217;s been used in hundreds of games across just about ever=
y system you can name. This includes top quality titles such as Night Sk=
y for the Wii and many #1 sellers on the iPhone App Store! I&#8217;ve pu=
t thousands of hours of work over many years to make Chipmunk what it is=
 today. If you find Chipmunk has saved you a lot of time, please conside=
r <a href=3D"https://www.paypal.com/cgi-bin/webscr?cmd=3D_s-xclick&amp;h=
osted_button_id=3D6666552">donating</a>. You&#8217;ll make an indie game=
 developer very happy!</p>
<p>First of all, I would like to give a Erin Catto a big thank you, as C=
hipmunk&#8217;s impulse solver was directly inspired by his example code=
 way back in 2006. (Now a full fledged physics engine all it&#8217;s own=
: <a href=3D"http://www.box2d.org/">Box2D.org</a>). His contact persiste=
nce idea allows for stable stacks of objects with very few iterations of=
 the solver. My previous solver produced mushy piles of objects or requi=
red a large amount of <span class=3D"caps">CPU</span> to operate stably.=
</p>
<h2><a name=3D"Intro-WhyC"></a><a href=3D"#Intro-WhyC">Why a C Library?<=
/a></h2>
<p>A lot of people ask me why I wrote Chipmunk in C instead of <em>pick =
your favorite language here</em>. I tend to get really excited about dif=
ferent programming languages. Depending on the month, take your pick of =
Scheme, OCaml, Ruby, Objective-C, <span class=3D"caps">OOC</span>, Lua, =
Io&#8230; the list goes on. The one common factor between most any langu=
age is that they are usually dead simple to make bindings to C code. I a=
lso wanted Chipmunk to be fast, portable, easy to optimize and easy to d=
ebug. Writting Chipmunk in C made it simpler to acheive all of those goa=
ls.</p>
<p>That said, I&#8217;ve never developed a whole game in C and I probabl=
y never will. There are much more interesting and fun languages than C w=
ith all sorts of nice features like garbage collection, closures and all=
 sorts of unique object oriented runtimes. Check out the <a href=3D"http=
://code.google.com/p/chipmunk-physics/wiki/BindingsAndPorts">Bindings an=
d Ports</a> page to see if you can use Chipmunk from your language of ch=
oice. Because Chipmunk is written in a subset of C99 it compiles cleanly=
 as C, C++, Objective-C and Objective-C++ code, making it easy to integr=
ate into projects in those languages.</p>
<p>If you are writing iPhone games using Chipmunk, you should check out =
the Objective-Chipmunk wrapper that we&#8217;ve developed for Chipmunk. =
It integrates with the Objective-C memory model and provides a number of=
 high level APIs that make writing physics based games for the iPhone ev=
en easier. While we do charge for Objective-Chipmunk, it will almost cer=
tainly save you more time than the small cost to license it. As a bonus,=
 you&#8217;ll be helping to ensure that we can afford to continue to wor=
k on Chipmunk improvements.</p>
<h2><a name=3D"Intro-Limitations"></a><a href=3D"#Intro-Limitations">Lim=
itations of a C <span class=3D"caps">API</span>:</a></h2>
<p>Chipmunk does provide overloaded operators for <code>*</code>, <code>=
+</code>, and <code>-</code> (unary and binary) if you are using C++, bu=
t falls back to using functions such as <code>cpvadd()</code> and <code>=
cpvsub()</code> for C code. This is a little harder to read, but works O=
K once you get used to it. Most of the interesting vector operations tha=
t are possible don&#8217;t have a symbol for them anyway (at least not o=
n a keyboard).</p>
<p>Another problem for a C <span class=3D"caps">API</span> is access res=
triction. There are many structs, fields and functions in Chipmunk that =
are only meant to be used internally. To work around this, I have a sepa=
rate header full of Chipmunk&#8217;s private <span class=3D"caps">API</s=
pan>, <code>chipmunk_private.h</code>. I also use a macro, <code>CP_PRIV=
ATE()</code> to mangle names in public structures. While you can feel fr=
ee to include this header or use the macro in your own code to access th=
e private <span class=3D"caps">API</span>, be aware that the fields and =
functions may be renamed or disappear without warning and I have no plan=
s to document or support usage of the private <span class=3D"caps">API</=
span>.</p>
<h2><a name=3D"Intro-Compiling"></a><a href=3D"#Intro-Compiling">Get it,=
 Compile it:</a></h2>
<p>If you haven&#8217;t downloaded it yet, you can always download the n=
ewest version of Chipmunk <a href=3D"http://files.slembcke.net/chipmunk/=
release/ChipmunkLatest.tgz">here</a>. Inside you&#8217;ll find a command=
 line build script that works with <a href=3D"http://www.cmake.org/">CMa=
ke</a>, a XCode project and project files for Visual Studio &#8217;09 an=
d &#8217;10.</p>
<h3><a name=3D"Intro-Compiling-DebugRelease"></a><a href=3D"#Intro-Compi=
ling-DebugRelease">Debug or Release?</a></h3>
<p>Debug mode might be slightly slower, but will include a lot of error =
checking assertions that can help you find bugs quicker such as removing=
 objects twice or doing things that might cause unsolvable collisions. I=
 highly recommend you use a debug build until you are ready to ship the =
game and only then switch to a release build.</p>
<h3><a name=3D"Intro-Compiling-XCode"></a><a href=3D"#Intro-Compiling-XC=
ode">XCode (Mac/iPhone)</a></h3>
<p>The included XCode project has targets for building a static library =
for the Mac or iOS. Additionally, you might want to just run the <code>m=
acosx/iphonestatic.command</code> or <code>macosx/macstatic.command</cod=
e> to build you a directory with the headers and debug/release static li=
braries that you can just drop right into your projects. Including Chipm=
unk in your project with all the correct compiler flags applied couldn&#=
8217;t be simpler. The iPhone script generates a &#8220;fat&#8221; libra=
ry that can be used with both the iOS simulator and devices. The device =
version is compiled as release, and the simulator version is compiled as=
 debug.</p>
<h3><a name=3D"Intro-Compiling-MSVC"></a><a href=3D"#Intro-Compiling-MSV=
C"><span class=3D"caps">MSVC</span></a></h3>
<p>I rarely use <span class=3D"caps">MSVC</span>, but others have chippe=
d in to help me maintain Visual Studio project files. Let me know if the=
re are any issues.</p>
<h3><a name=3D"Intro-Compiling-CommandLine"></a><a href=3D"#Intro-Compil=
ing-CommandLine">Command Line</a></h3>
<p>The CMake build script should work on any system (Unix/Win/Mac) as lo=
ng as you have CMake installed. It can even generate XCode or <span clas=
s=3D"caps">MSVC</span> projects if you want (see CMake&#8217;s documenta=
tion for more information).</p>
<p>To compile a Chipmunk debug build on the command line, all you need t=
o do is run:</p>
<pre><code>cmake -D CMAKE_BUILD_TYPE=3DDebug .
make</code></pre>
<p>If the <code>-D CMAKE_BUILD_TYPE=3DDebug</code> option is left out, i=
t will make a release build instead.</p>
<h2><a name=3D"Intro-HelloChipmunk"></a><a href=3D"#Intro-HelloChipmunk"=
>Hello Chipmunk (World)</a></h2>
<p>Hello world Chipmunk style. Create a simple simulation where a ball f=
alls onto a static line segment, then rolls off. Print out the coordinat=
es of the ball.</p>
<div><a class=3D"HideShow" href=3D"javascript:;" onmousedown=3D"toggleEx=
ample('Pop Open Hello Chipmunk Example', 'examples/Hello%20Chipmunk.html=
');">Hide/Show Hello Chipmunk Example</a><div id=3D"Pop Open Hello Chipm=
unk Example" style=3D"display:none"></div></div>
<h2><a name=3D"Intro-Support"></a><a href=3D"#Intro-Support">Support:</a=
></h2>
<p>The best way to get support is to visit the <a href=3D"http://www.sle=
mbcke.net/forums/viewforum.php?f=3D1">Chipmunk Forums</a>. There are ple=
nty of people around using Chipmunk on the just about every platform I&#=
8217;ve ever heard of. If you are working on a commercial project, Howli=
ng Moon Software (my company) is <a href=3D"http://howlingmoonsoftware.c=
om/contracting.php">available for contracting</a>. We can help with impl=
ementing custom Chipmunk behaviors, as well as priority bug fixes and pe=
rformance tuning.</p>
<h2><a name=3D"Intro-ContactUS"></a><a href=3D"#Intro-ContactUS">Contact=
:</a></h2>
<p>If you find any bugs in Chipmunk, errors or broken links in this docu=
ment, or have a question or comment about Chipmunk you can contact me at=
 slembcke(at)gmail(dot)com. (email or GTalk)</p>
<h2><a name=3D"Intro-License"></a><a href=3D"#Intro-License">License:</a=
></h2>
<p>Chipmunk is licensed under the <span class=3D"caps">MIT</span> licens=
e.</p>
<pre>
Copyright (c) 2007-2011 Scott Lembcke

Permission is hereby granted, free of charge, to any person obtaining a =
copy
of this software and associated documentation files (the "Software"), to=
 deal
in the Software without restriction, including without limitation the ri=
ghts
to use, copy, modify, merge, publish, distribute, sublicense, and/or sel=
l
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included =
in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS =
OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,=

FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL =
THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING =
FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS I=
N THE
SOFTWARE.
</pre>
<p>This means that you do not have to buy a license or pay to use Chipmu=
nk in commercial projects. (Though we really appreciate donations)</p>
<h2><a name=3D"Intro-Links"></a><a href=3D"#Intro-Links">Links:</a></h2>=

<ul>
	<li><a href=3D"http://www.slembcke.net/forums/viewforum.php?f=3D1">slem=
bcke.net/forums</a> &#8211; The official forum Chipmunk Physics forum.</=
li>
	<li><a href=3D"http://howlingmoonsoftware.com/">Howling Moon Software</=
a> &#8211;  My software company.</li>
	<li><a href=3D"http://howlingmoonsoftware.com/objectiveChipmunk.php">Ob=
jective-Chipmunk</a> &#8211; An Objective-C wrapper that makes developin=
g Chipmunk apps on the iPhone a snap.</li>
	<li><a href=3D"http://code.google.com/p/chipmunk-physics/wiki/Games">Ga=
mes</a> &#8211; A small list of games done with Chipmunk.</li>
	<li><a href=3D"http://code.google.com/p/chipmunk-physics/wiki/BindingsA=
ndPorts">Bindings and Ports</a> &#8211; A list of bindings and ports of =
Chipmunk to other languages.</li>
</ul>
<h1><a name=3D"Basics"></a><a href=3D"#Basics">Chipmunk Basics:</a></h1>=

<h2><a name=3D"Basics-Overview"></a><a href=3D"#Basics-Overview">Overvie=
w:</a></h2>
<p>There are 4 basic object types you will use in Chipmunk.</p>
<ul>
	<li><strong>Rigid Bodies:</strong> A rigid body holds the physical prop=
erties of an object. (mass, position, rotation, velocity, etc.) It does =
not have a shape until you attach one or more collision shapes to it. If=
 you=E2=80=99ve done physics with particles before, rigid bodies differ =
in that they are able to rotate. Rigid bodies generally tend to have a 1=
:1 correlation to sprites in a game. You should structure your game so t=
hat you use the position and rotation of the rigid body for drawing your=
 sprite.</li>
	<li><strong>Collision Shapes:</strong> By attaching shapes to bodies, y=
ou can define the a body=E2=80=99s shape. You can attach as many shapes =
to a single body as you need to in order to define a complex shape. Shap=
es contain the surface properties of an object such as how much friction=
 or elasticity it has.</li>
	<li><strong>Constraints/Joints:</strong> Constraints and joints describ=
e how bodies are attached to each other.</li>
	<li><strong>Spaces:</strong> Spaces are containers for simulating objec=
ts in Chipmunk. You add bodies, shapes and joints to a space and then up=
date the space as a whole. They control how all the rigid bodies, shapes=
, and</li>
</ul>
<p>There is often confusion between rigid bodies and their collision sha=
pes in Chipmunk and how they relate to sprites. A sprite would be a visu=
al representation of an object, while a collision shape is an invisible =
property that defines how objects should collide. Both the sprite&#8217;=
s and the collision shape&#8217;s position and rotation are controlled b=
y the motion of a rigid body. Generally you want to create a game object=
 type that ties these things all together.</p>
<h2><a name=3D"Basics-Memory"></a><a href=3D"#Basics-Memory">Memory Mana=
gement the Chipmunk way:</a></h2>
<p>For most of the structures you will use, Chipmunk uses a more or less=
 standard and straightforward set of memory management functions. Take t=
he <a href=3D"#cpSpace">cpSpace</a> struct for example:</p>
<ul>
	<li><code>cpSpaceNew()</code> &#8211; Allocates and initializes a <code=
>cpSpace</code> struct. It calls <code>cpSpaceAlloc()</code> then <code>=
cpSpaceInit()</code>.</li>
	<li><code>cpSpaceFree(cpSpace *space)</code> &#8211;  Destroys and free=
s the <code>cpSpace</code> struct.</li>
</ul>
<p>You are responsible for freeing any structs that you allocate. Chipmu=
nk does not do reference counting or garbage collection. If you call a <=
code>new</code> function, you must call the matching <code>free</code> f=
unction or you will leak memory.</p>
<p>Additionally if you need more control over allocation and initializat=
ion because you are allocating temporary structs on the stack, writting =
a language binding, or working in a low memory environment you can also =
use the following functions. <em>Most people will never have any need to=
 use these functions.</em></p>
<ul>
	<li><code>cpSpaceAlloc()</code> &#8211; Allocates but does not initiali=
ze a <code>cpSpace</code> struct. All allocation functions look more or =
less like this: <code>return (cpSpace *)cpcalloc(1, sizeof(cpSpace));</c=
ode> You can write your own allocation functions if you want. It is not =
a requirement that the memory be zeroed.</li>
	<li><code>cpSpaceInit(cpSpace *space)</code> &#8211; Initializes a <cod=
e>cpSpace</code> struct.</li>
	<li><code>cpSpaceDestroy(cpSpace *space)</code> &#8211; Frees all memor=
y allocated by <code>cpSpaceInit()</code>, but does not free the <code>c=
pSpace</code> struct itself.</li>
</ul>
<p>Like calls to the <code>new</code> and <code>free</code> functions. A=
ny memory allocated by an <code>alloc</code> function must be freed by <=
code>cpfree()</code> or similar. Any call to an <code>init</code> functi=
on must be matched with it&#8217;s <code>destroy</code> function.</p>
<p>To further ease integration with garbage collectors or other memory m=
anagement constraints, Chipmunk has a number of compile time defines (<c=
ode>cpcalloc()</code>, <code>cprealloc()</code>, and <code>cpfree()</cod=
e>) that can be overriden. If you aren&#8217;t using Chipmunk from a gar=
bage collected language, I&#8217;d highly recommend using libGC. It prov=
ides nearly transparent garbage collection for C based languages.</p>
<h2><a name=3D"Basics-Types"></a><a href=3D"#Basics-Types">Basic Types:<=
/a></h2>
<p><code>chipmunk_types.h</code> defines a number of basic types that Ch=
ipmunk uses. These can be changed at compile time to better suit your ne=
eds:</p>
<ul>
	<li><code>cpFloat</code>: Floating point type. Defaults to <code>double=
</code>.</li>
	<li><code>cpVect</code>: 2D vector type. <a href=3D"#cpVect">cpVect doc=
umentation</a></li>
	<li><code>cpBool</code>: Like every good C library that wants good cros=
s language compatibility, you end up defining your own boolean type. :-\=
 Defaults to <code>int</code>.</li>
	<li><code>cpDataPointer</code>: Pointer type defined for callbacks and =
the user definable data pointer on most Chipmunk structs. Defaults to <c=
ode>void*</code>.</li>
	<li><code>cpCollisionType</code>: Unique identifier for collision shape=
 types. Defaults to <code>unsigned int</code>. Defined type must support=
 the <code>=3D=3D</code> operator.</li>
	<li><code>cpGroup</code>: Unique identifier for collision groups. Defau=
lts to <code>unsigned int</code>. A <code>CP_NO_GROUP</code> value is de=
fined that can be used when you don&#8217;t want to specify a group. Def=
ined type must support the equality <code>=3D=3D</code> operator.</li>
	<li><code>cpLayers</code>: Type used as the layers bitmask. Defaults to=
 <code>unsigned int</code>. A <code>CP_ALL_LAYERS</code> value is define=
d that has all layer bits set. Defined type must support the bitwise <sp=
an class=3D"caps">AND</span> <code>&amp;</code> operator.</li>
</ul>
<p>If you are writting a game engine or language binding on top of Chipm=
unk, you might want to choose to use object references instead of intege=
rs for collision type and group. I often use class pointers for collisio=
n types and game object pointers for groups. It&#8217;s much simpler tha=
n keeping a table of enumerations around.</p>
<p><strong>Note:</strong> On the iPhone, <code>cpFloat</code> is defined=
 as <code>float</code> and <code>cpVect</code> is an alias for <code>CGP=
oint</code> for performance and compatibility reasons.</p>
<h2><a name=3D"Basics-Math"></a><a href=3D"#Basics-Math">Math the Chipmu=
nk way:</a></h2>
<p>First of all, Chipmunk uses double precision floating point numbers t=
hroughout it&#8217;s calculations by default. This is likely to be faste=
r on most modern desktop processors, and means you have to worry less ab=
out floating point round off errors. You can change the floating point t=
ype used by Chipmunk when compiling the library. Look in <code>chipmunk_=
types.h</code>.</p>
<p>Chipmunk defines a number of aliases for common math functions so tha=
t you can choose to use floats or doubles for Chipmunk&#8217;s floating =
point type. In your own code, there probably isn&#8217;t a strong reason=
 to use these aliases unless you expect you might want to change Chipmun=
k&#8217;s floating point type later and a 2% performance hit from using =
the wrong float/double version of math functions will matter.</p>
<p>There are a few unique functions you will probably find very useful:<=
/p>
<ul>
	<li><code>cpFloat cpfclamp(cpFloat f, cpFloat min, cpFloat max)</code> =
&#8211; Clamp <code>f</code> to be between <code>min</code> and <code>ma=
x</code>.</li>
	<li><code>cpFloat cpflerp(cpFloat f1, cpFloat f2, cpFloat t)</code> &#8=
211; Linearly interpolate between <code>f1</code> and <code>f2</code>.</=
li>
	<li><code>cpFloat cpflerpconst(cpFloat f1, cpFloat f2, cpFloat d)</code=
> &#8211; Linearly interpolate from <code>f1</code> towards <code>f2</co=
de> by no more than <code>d</code>.</li>
</ul>
<p>Floating point infinity is defined as <code>INFINITY</code>. This is =
defined by many math libraries, but is not actually part of the C standa=
rd library.</p>
<h1><a name=3D"cpVect"></a><a href=3D"#cpVect">Chipmunk Vectors: <code>c=
pVect</code></a></h1>
<h2><a name=3D"cpVect-Basics"></a><a href=3D"#cpVect-Basics">Struct Defi=
nition, Constants and Constructors:</a></h2>

<pre><code>typedef struct cpVect{
	cpFloat x, y;
} cpVect</code></pre>
<p class=3D"expl">2D vector packed into a struct. No surprises here.</p>=

<pre><code>static const cpVect cpvzero =3D {0.0f,0.0f};</code></pre>
<p class=3D"expl">Constant for the zero vector.</p>
<pre><code>cpVect cpv(const cpFloat x, const cpFloat y)</code></pre>
<p class=3D"expl">Convenience constructor for creating new <code>cpVect<=
/code> structs.</p>
<h2><a name=3D"cpVect-Operations"></a><a href=3D"#cpVect-Operations">Ope=
rations:</a></h2>
<ul>
	<li><code>cpBool cpveql(const cpVect v1, const cpVect v2)</code> &#8211=
; Check if two vectors are equal. Chipmunk provides an overloaded <code>=
=3D=3D</code> operator when used in C++ programs. <em>(Be careful when c=
omparing floating point numbers!)</em></li>
	<li><code>cpVect cpvadd(const cpVect v1, const cpVect v2)</code> &#8211=
; Add two vectors. Chipmunk provides an overloaded <code>+</code> operat=
or when used in C++ programs.</li>
	<li><code>cpVect cpvsub(const cpVect v1, const cpVect v2)</code> &#8211=
; Subtract two vectors. Chipmunk provides an overloaded <code>-</code> o=
perator when used in C++ programs.</li>
	<li><code>cpVect cpvneg(const cpVect v)</code> &#8211; Negate a vector.=
 Chipmunk provides an overloaded unary negation operator <code>-</code> =
when used in C++ programs.</li>
	<li><code>cpVect cpvmult(const cpVect v, const cpFloat s)</code> &#8211=
; Scalar multiplication. Chipmunk provides an overloaded <code>*</code> =
operator when used in C++ programs.</li>
	<li><code>cpFloat cpvdot(const cpVect v1, const cpVect v2)</code> &#821=
1; Vector dot product.</li>
	<li><code>cpFloat cpvcross(const cpVect v1, const cpVect v2)</code> &#8=
211; 2D vector cross product analog. The cross product of 2D vectors res=
ults in a 3D vector with only a z component. This function returns the v=
alue along the z-axis.</li>
	<li><code>cpVect cpvperp(const cpVect v)</code> &#8211; Returns a perpe=
ndicular vector. (90 degree rotation)</li>
	<li><code>cpVect cpvrperp(const cpVect v)</code> &#8211; Returns a perp=
endicular vector. (-90 degree rotation)</li>
	<li><code>cpVect cpvproject(const cpVect v1, const cpVect v2)</code> &#=
8211; Returns the vector projection of <code>v1</code> onto <code>v2</co=
de>.</li>
	<li><code>cpVect cpvrotate(const cpVect v1, const cpVect v2)</code> &#8=
211; Uses complex multiplication to rotate <code>v1</code> by <code>v2</=
code>. Scaling will occur if <code>v1</code> is not a unit vector.</li>
	<li><code>cpVect cpvunrotate(const cpVect v1, const cpVect v2)</code> &=
#8211; Inverse of <code>cpvrotate()</code>.</li>
	<li><code>cpFloat cpvlength(const cpVect v)</code> &#8211; Returns the =
length of <code>v</code>.</li>
	<li><code>cpFloat cpvlengthsq(const cpVect v)</code> &#8211; Returns th=
e squared length of <code>v</code>. Faster than <code>cpvlength()</code>=
 when you only need to compare lengths.</li>
	<li><code>cpVect cpvlerp(const cpVect v1, const cpVect v2, const cpFloa=
t t)</code> &#8211; Linearly interpolate between <code>v1</code> and <co=
de>v2</code>.</li>
	<li><code>cpVect cpvlerpconst(cpVect v1, cpVect v2, cpFloat d)</code> &=
#8211; Linearly interpolate between <code>v1</code> towards <code>v2</co=
de> by distance <code>d</code>.</li>
	<li><code>cpVect cpvslerp(const cpVect v1, const cpVect v2, const cpFlo=
at t)</code> &#8211; Spherical linearly interpolate between <code>v1</co=
de> and <code>v2</code>.</li>
	<li><code>cpVect cpvslerpconst(const cpVect v1, const cpVect v2, const =
cpFloat a)</code> &#8211; Spherical linearly interpolate between <code>v=
1</code> towards <code>v2</code> by no more than angle @a@&#8217; in rad=
ians.</li>
	<li><code>cpVect cpvnormalize(const cpVect v)</code> &#8211; Returns a =
normalized copy of <code>v</code>.</li>
	<li><code>cpVect cpvnormalize_safe(const cpVect v)</code> &#8211; Retur=
ns a normalized copy of <code>v</code> or <code>cpvzero</code> if <code>=
v</code> was already <code>cpvzero</code>. Protects against divide by ze=
ro errors.</li>
	<li><code>cpVect cpvclamp(const cpVect v, const cpFloat len)</code> &#8=
211; Clamp <code>v</code> to length <code>len</code>.</li>
	<li><code>cpFloat cpvdist(const cpVect v1, const cpVect v2)</code> &#82=
11; Returns the distance between <code>v1</code> and <code>v2</code>.</l=
i>
	<li><code>cpFloat cpvdistsq(const cpVect v1, const cpVect v2)</code> &#=
8211; Returns the squared distance between <code>v1</code> and <code>v2<=
/code>. Faster than <code>cpvdist()</code> when you only need to compare=
 distances.</li>
	<li><code>cpBool cpvnear(const cpVect v1, const cpVect v2, const cpFloa=
t dist)</code> &#8211; Returns true if the distance between <code>v1</co=
de> and <code>v2</code> is less than <code>dist</code>.</li>
	<li><code>cpVect cpvforangle(const cpFloat a)</code> &#8211; Returns th=
e unit length vector for the given angle (in radians).</li>
	<li><code>cpFloat cpvtoangle(const cpVect v)</code> &#8211; Returns the=
 angular direction <code>v</code> is pointing in (in radians).</li>
</ul>
<h1><a name=3D"cpBB"></a><a href=3D"#cpBB">Chipmunk Axis Aligned Boundin=
g Boxes: <code>cpBB</code></a></h1>
<h2><a name=3D"cpBB-Basics"></a><a href=3D"#cpBB-Basics">Struct Definiti=
on and Constructors:</a></h2>

<pre><code>typedef struct cpBB{
	cpFloat l, b, r ,t;
} cpBB</code></pre>
<p class=3D"expl">Simple bounding box struct. Stored as left, bottom, ri=
ght, top values.</p>
<pre><code>cpBB cpBBNew(const cpFloat l, const cpFloat b, const cpFloat =
r, const cpFloat t)</code></pre>
<p class=3D"expl">Convenience constructor for <code>cpBB</code> structs.=
 Like <code>cpv()</code> this function returns a copy and not a malloced=
 pointer.</p>
<pre><code>cpBB cpBBNewForCircle(const cpVect p, const cpFloat r)</code>=
</pre>
<p class=3D"expl">Convenience constructor for making a <code>cpBB</code>=
 fitting a circle at position <code>p</code> with radius <code>r</code>.=
</p>
<h2><a name=3D"cpBB-Operations"></a><a href=3D"#cpBB-Operations">Operati=
ons:</a></h2>
<ul>
	<li><code>cpBool cpBBIntersects(const cpBB a, const cpBB b)</code> &#82=
11; Returns true if the bounding boxes intersect.</li>
	<li><code>cpBool cpBBContainsBB(const cpBB bb, const cpBB other)</code>=
 &#8211; Returns true if <code>bb</code> completely contains <code>other=
</code>.</li>
	<li><code>cpBool cpBBContainsVect(const cpBB bb, const cpVect v)</code>=
 &#8211; Returns true if <code>bb</code> contains <code>v</code>.</li>
	<li><code>cpBB cpBBMerge(const cpBB a, const cpBB b)</code> &#8211; Ret=
urn the minimal bounding box that contains both <code>a</code> and <code=
>b</code>.</li>
	<li><code>cpBB cpBBExpand(const cpBB bb, const cpVect v)</code> &#8211;=
 Return the minimal bounding box that contains both <code>bb</code> and =
<code>v</code>.</li>
	<li><code>cpFloat cpBBArea(cpBB bb)</code> &#8211; Return the area of <=
code>bb</code>.</li>
	<li><code>cpFloat cpBBMergedArea(cpBB a, cpBB b)</code> &#8211; Merges =
<code>a</code> and <code>b</code> then returns the area of the merged bo=
unding box.</li>
	<li><code>cpFloat cpBBSegmentQuery(cpBB bb, cpVect a, cpVect b)</code> =
&#8211; Returns the fraction along the segment query the cpBB is hit. Re=
turns <span class=3D"caps">INFINITY</span> if it doesn&#8217;t hit.</li>=

	<li><code>cpBool cpBBIntersectsSegment(cpBB bb, cpVect a, cpVect b)</co=
de> &#8211; Returns true if the segment defined by endpoints <code>a</co=
de> and <code>b</code> intersect <code>bb</code>.</li>
	<li><code>cpVect cpBBClampVect(const cpBB bb, const cpVect v)</code> &#=
8211; Returns a copy of <code>v</code> clamped to the bounding box.</li>=

	<li><code>cpVect cpBBWrapVect(const cpBB bb, const cpVect v)</code> &#8=
211; Returns a copy of <code>v</code> wrapped to the bounding box.</li>
</ul>
<h1><a name=3D"cpBody"></a><a href=3D"#cpBody">Chipmunk Rigid Bodies: <c=
ode>cpBody</code></a></h1>
<h2><a name=3D"cpBody-RougeStatic"></a><a href=3D"#cpBody-RougeStatic">R=
ogue and Static Bodies:</a></h2>
<p>Normally when you create a rigid body, you add it to a space so the s=
pace will start simulating it. This means it will update it&#8217;s posi=
tion and velocity, apply forces to it, be affected by gravity, etc. A bo=
dy that isn&#8217;t added to a space (and not simulated) is called a <em=
>rogue body</em>. The most important use for rogue bodies are as static =
bodies, but you can also use them to implement directly controlled objec=
ts such as moving platforms.</p>
<p>Static bodies are rogue bodies, but with a special flag set on them t=
o let Chipmunk know that they never move unless you tell it. Static bodi=
es have two purposes. Originally they were added for the sleeping featur=
e. Because static bodies don&#8217;t move, Chipmunk knows that it&#8217;=
s safe to let objects that are touching or jointed to them fall asleep. =
Objects touching or jointed to regular rogue bodies are never allowed to=
 sleep. The second purpose for static bodies is that Chipmunk knows shap=
es attached to them never need to have their collision detection data up=
dated. Chipmunk also doesn&#8217;t need to bother checking for collision=
s between static objects. Generally all of your level geometry will be a=
ttached to a static body except for things like moving platforms or door=
s.</p>
<p>In previous versions of Chipmunk before 5.3 you would create an infin=
ite mass rogue body to attach static shapes to using <code>cpSpaceAddSta=
ticShape()</code>. You don&#8217;t need to do any of that anymore, and s=
houldn&#8217;t if you want to use the sleeping feature. Each space has a=
 dedicated static body that you can use to attach your static shapes to.=
 Chipmunk also automatically adds shapes attached to static bodies as st=
atic shapes.</p>
<h2><a name=3D"cpBody-Memory"></a><a href=3D"#cpBody-Memory">Memory Mana=
gement Functions:</a></h2>

<pre><code>cpBody *cpBodyAlloc(void)
cpBody *cpBodyInit(cpBody *body, cpFloat m, cpFloat i)
cpBody *cpBodyNew(cpFloat m, cpFloat i)

void cpBodyDestroy(cpBody *body)
void cpBodyFree(cpBody *body)</code></pre>
<p class=3D"expl">Standard set of Chipmunk memory management functions. =
<code>m</code> and <code>i</code> are the mass and moment of inertia for=
 the body. Guessing the mass for a body is usually fine, but guessing a =
moment of inertia can lead to a very poor simulation. Be careful not to =
free a body before any shapes or constraints attached to it have been re=
moved from a space.</p>
<h2><a name=3D"cpBody-StaticBodies"></a><a href=3D"#cpBody-StaticBodies"=
>Creating Additional Static Bodies:</a></h2>
<p>While every cpSpace has a built in static body that you can use, it c=
an be convenient to make your own as well. One potential use is in a lev=
el editor. By attaching chunks of your level to static bodies, you can s=
till move and rotate the chunks independently of each other. Then all yo=
u have to do is call <code>cpSpaceRehashStatic()</code> to rebuild the s=
tatic collision detection data when you are done.</p>
<p>For more information on rogue and static bodies, see <a href=3D"#cpSp=
ace">Chipmunk Spaces</a>.</p>
<pre><code>cpBody *cpBodyAlloc(void);
cpBody *cpBodyInitStatic(cpBody *body)
cpBody *cpBodyNewStatic()</code></pre>
<p class=3D"expl">Create additional static bodies with infinite mass and=
 moment of inertia.</p>
<h2><a name=3D"cpBody-Properties"></a><a href=3D"#cpBody-Properties">Pro=
perties:</a></h2>
<p>Chipmunk provides getter/setter functions for a number of properties =
on rigid bodies. Setting most properties automatically wakes the rigid b=
odies up if they were sleeping. You can also set the fields directly on =
the cpBody struct if you wish. They are documented in the headers.</p>
<pre><code>cpFloat cpBodyGetMass(const cpBody *body)
void cpBodySetMass(cpBody *body, cpFloat m)</code></pre>
<p class=3D"expl">Mass of the body.</p>
<pre><code>cpFloat cpBodyGetMoment(const cpBody *body)
void cpBodySetMoment(cpBody *body, cpFloat i)</code></pre>
<p class=3D"expl">Moment of inertia (MoI or sometimes just moment) of th=
e body. The moment is like the rotational mass of a body. See below for =
function to help calculate the moment.</p>
<pre><code>cpVect cpBodyGetPos(const cpBody *body)
void cpBodySetPos(cpBody *body, cpVect pos)</code></pre>
<p class=3D"expl">Position of the center of gravity of the body. When ch=
anging the position you may also want to call <code>cpSpaceReindexShapes=
ForBody()</code> to update the collision detection information for the a=
ttached shapes if plan to make any queries against the space.</p>
<pre><code>cpVect cpBodyGetVel(const cpBody *body)
void cpBodySetVel(cpBody *body, const cpVect value)</code></pre>
<p class=3D"expl">Linear velocity of the center of gravity of the body.<=
/p>
<pre><code>cpVect cpBodyGetForce(const cpBody *body)
void cpBodySetForce(cpBody *body, const cpVect value)</code></pre>
<p class=3D"expl">Force applied to the center of gravity of the body.</p=
>
<pre><code>cpFloat cpBodyGetAngle(const cpBody *body)
void cpBodySetAngle(cpBody *body, cpFloat a)</code></pre>
<p class=3D"expl">Rotation of the body in radians. When changing the rot=
ation you may also want to call <code>cpSpaceReindexShapesForBody()</cod=
e> to update the collision detection information for the attached shapes=
 if plan to make any queries against the space.</p>
<pre><code>cpFloat cpBodyGetAngVel(const cpBody *body)
void cpBodySetAngVel(cpBody *body, const cpFloat value)</code></pre>
<p class=3D"expl">The angular velocity of the body in radians per second=
.</p>
<pre><code>cpFloat cpBodyGetTorque(const cpBody *body)
void cpBodySetTorque(cpBody *body, const cpFloat value)</code></pre>
<p class=3D"expl">The torque applied to the body.</p>
<pre><code>cpVect cpBodyGetRot(const cpBody *body)</code></pre>
<p class=3D"expl">The rotation vector for the body. Can be used with <co=
de>cpvrotate()</code> or <code>cpvunrotate()</code> to perform fast rota=
tions.</p>
<pre><code>cpFloat cpBodyGetVelLimit(const cpBody *body)
void cpBodySetVelLimit(cpBody *body, const cpFloat value)</code></pre>
<p class=3D"expl">Velocity limit of the body. Defaults to <code>INFINITY=
</code> unless you set it specifically. Can be used to limit falling spe=
eds, etc.</p>
<pre><code>cpFloat cpBodyGetAngVelLimit(const cpBody *body)
void cpBodySetAngVelLimit(cpBody *body, const cpFloat value)</code></pre=
>
<p class=3D"expl">Angular velocity limit of the body in radians per seco=
nd. Defaults to <code>INFINITY</code> unless you set it specifically.</p=
>
<pre><code>cpDataPointer cpBodyGetUserData(const cpBody *body)
void cpBodySetUserData(cpBody *body, const cpDataPointer value)</code></=
pre>
<p class=3D"expl">User data pointer. Use this pointer to get a reference=
 to the game object that owns this body from callbacks.</p>
<h2><a name=3D"cpBody-Helpers"></a><a href=3D"#cpBody-Helpers">Moment of=
 Inertia and Area Helper Functions:</a></h2>
<p>Use the following functions to approximate the moment of inertia for =
your body, adding the results together if you want to use more than one.=
</p>
<ul>
	<li><code>cpFloat cpMomentForCircle(cpFloat m, cpFloat r1, cpFloat r2, =
cpVect offset)</code> &#8211; Calculate the moment of inertia for a holl=
ow circle, <code>r1</code> and <code>r2</code> are the inner and outer d=
iameters in no particular order. <em>(A solid circle has an inner diamet=
er of 0)</em></li>
	<li><code>cpFloat cpMomentForSegment(cpFloat m, cpVect a, cpVect b)</co=
de> &#8211; Calculate the moment of inertia for a line segment. The endp=
oints <code>a</code> and <code>b</code> are relative to the body.</li>
	<li><code>cpFloat cpMomentForPoly(cpFloat m, int numVerts, const cpVect=
 *verts, cpVect offset)</code> &#8211; Calculate the moment of inertia f=
or a solid polygon shape assuming it&#8217;s center of gravity is at it&=
#8217;s centroid. The offset is added to each vertex.</li>
	<li><code>cpFloat cpMomentForBox(cpFloat m, cpFloat width, cpFloat heig=
ht)</code> &#8211; Calculate the moment of inertia for a solid box cente=
red on the body.</li>
</ul>
<p><!-- TODO poly examples --></p>
<div><a class=3D"HideShow" href=3D"javascript:;" onmousedown=3D"toggleEx=
ample('Pop Open Moments Example', 'examples/Moments.html');">Hide/Show M=
oments Example</a><div id=3D"Pop Open Moments Example" style=3D"display:=
none"></div></div>
<p>Use the following functions to get the area for common Chipmunk shape=
s if you want to approximate masses or density or whatnot.</p>
<ul>
	<li><code>cpFloat cpAreaForCircle(cpFloat r1, cpFloat r2)</code> &#8211=
; Area of a hollow circle.</li>
	<li><code>cpFloat cpAreaForSegment(cpVect a, cpVect b, cpFloat r)</code=
> &#8211; Area of a beveled segment. <em>(Will always be zero if radius =
is zero)</em></li>
	<li><code>cpFloat cpAreaForPoly(const int numVerts, const cpVect *verts=
)</code> &#8211; Signed area of a polygon shape. Returns a negative numb=
er for polygons with a backwards winding.</li>
</ul>
<h2><a name=3D"cpBody-CoordinateConversion"></a><a href=3D"#cpBody-Coord=
inateConversion">Coordinate Conversion Functions:</a></h2>
<p>Many things are defined in coordinates local to a body meaning that t=
he (0,0) is at the center of gravity of the body and the axis rotate alo=
ng with the body.</p>
<ul>
	<li><code>cpVect cpBodyLocal2World(const cpBody *body, const cpVect v)<=
/code> &#8211; Convert from body local coordinates to world space coordi=
nates.</li>
	<li><code>cpVect cpBodyWorld2Local(const cpBody *body, const cpVect v)<=
/code> &#8211; Convert from world space coordinates to body local coordi=
nates.</li>
</ul>
<h2><a name=3D"cpBody-Forces"></a><a href=3D"#cpBody-Forces">Applying Fo=
rces and Torques:</a></h2>
<p>People are sometimes confused by the difference between a force and a=
n impulse. An impulse is basically a very large force applied over a ver=
y short period of time, like a ball hitting a wall or cannon firing. Chi=
pmunk treats impulses as if they occur instantaneously by simply adding =
directly to the velocity of an object. Both impulses and forces are affe=
cted the mass of an object. Double the mass of the object and halve the =
effect.</p>
<ul>
	<li><code>void cpBodyResetForces(cpBody *body)</code> &#8211; Zero both=
 the forces and torques currently applied to the body.</li>
	<li><code>void cpBodyApplyForce(cpBody *body, const cpVect f, const cpV=
ect r)</code> &#8211; Add the force <code>j</code> to <code>body</code> =
at a relative offset <code>r</code> from the center of gravity.</li>
	<li><code>void cpBodyApplyImpulse(cpBody *body, const cpVect j, const c=
pVect r)</code> &#8211; Add the impulse <code>f</code> to <code>body</co=
de> at a relative offset <code>r</code> from the center of gravity.</li>=

</ul>
<p><strong>Note:</strong> Both the <code>cpBodyApplyForce()</code> <code=
>cpBodyApplyImpulse()</code> functions take a force or impulse in absolu=
te coordinates and applies it at a relative offset in absolute coordinat=
es. (The offset is relative to the center of gravity, but is <em>not</em=
> rotated with the body)</p>
<h2><a name=3D"cpBody-Sleeping"></a><a href=3D"#cpBody-Sleeping">Sleepin=
g Functions:</a></h2>
<p>Chipmunk supports a sleeping feature so that it stops using <span cla=
ss=3D"caps">CPU</span> time simulating groups of objects that stop movin=
g. Read more about it in the <a href=3D"#cpSpace-Sleeping">cpSpace secti=
on</a>.</p>
<ul>
	<li><code>cpBool cpBodyIsSleeping(const cpBody *body)</code> &#8211; Re=
turns true if <code>body</code> is sleeping.</li>
	<li><code>void cpBodyActivate(cpBody *body)</code> &#8211; Reset the id=
le timer on a body. If it was sleeping, wake it and any other bodies it =
was touching.</li>
	<li><code>void cpBodySleep(cpBody *body)</code> &#8211; Forces a body t=
o fall asleep immediately even if it&#8217;s in midair. Cannot be called=
 from a callback.</li>
	<li><code>void cpBodyActivateStatic(cpBody *body, cpShape *filter)</cod=
e> &#8211; Similar in function to <code>cpBodyActivate()</code>. Activat=
es all bodies touching <code>body</code>. If <code>filter</code> is not =
<code>NULL</code>, then only bodies touching through <code>filter</code>=
 will be awoken.</li>
</ul>
<pre><code>void cpBodySleepWithGroup(cpBody *body, cpBody *group)</code>=
</pre>
<p class=3D"expl">When objects in Chipmunk sleep, they sleep as a group =
of all objects that are touching or jointed together. When an object is =
woken up, all of the objects in it&#8217;s group are woken up. <code>cpB=
odySleepWithGroup()</code> allows you group sleeping objects together. I=
t acts identically to <code>cpBodySleep()</code> if you pass <code>NULL<=
/code> as <code>group</code> by starting a new group. If you pass a slee=
ping body for <code>group</code>, <code>body</code> will be awoken when =
<code>group</code> is awoken. You can use this to initialize levels and =
start stacks of objects in a pre-sleeping state.</p>
<div><a class=3D"HideShow" href=3D"javascript:;" onmousedown=3D"toggleEx=
ample('Pop Open Sleeping Example', 'examples/Sleeping.html');">Hide/Show=
 Sleeping Example</a><div id=3D"Pop Open Sleeping Example" style=3D"disp=
lay:none"></div></div>
<h2><a name=3D"cpBody-Iterators"></a><a href=3D"#cpBody-Iterators">Itera=
tors</a></h2>

<pre><code>typedef void (*cpBodyShapeIteratorFunc)(cpBody *body, cpShape=
 *shape, void *data)
void cpBodyEachShape(cpBody *body, cpBodyShapeIteratorFunc func, void *d=
ata)</code></pre>
<p class=3D"expl">Call <code>func</code> once for each shape that is att=
ached to <code>body</code> and added to a space. <code>data</code> is pa=
ssed along as a context value. It is safe to remove shapes using these c=
allbacks.</p>
<pre><code>typedef void (*cpBodyConstraintIteratorFunc)(cpBody *body, cp=
Constraint *constraint, void *data)
void cpBodyEachConstraint(cpBody *body, cpBodyConstraintIteratorFunc fun=
c, void *data)</code></pre>
<p class=3D"expl">Call <code>func</code> once for each constraint that i=
s attached to <code>body</code> and added to a space. <code>data</code> =
is passed along as a context value. It is safe to remove constraints usi=
ng thes callbacks.</p>
<pre><code>typedef void (*cpBodyArbiterIteratorFunc)(cpBody *body, cpArb=
iter *arbiter, void *data)
void cpBodyEachArbiter(cpBody *body, cpBodyArbiterIteratorFunc func, voi=
d *data)</code></pre>
<p class=3D"expl">This one is more interesting. Calls <code>func</code> =
once for each collision pair that <code>body</code> is involved in. Call=
ing <code>cpArbiterGet[Bodies|Shapes]()</code> or <code>CP_ARBITER_GET_[=
BODIES|SHAPES]()</code>  will return the body or shape for <code>body</c=
ode> as the first argument. You can use this to check all sorts of colli=
sion information for a body like if it&#8217;s touching the ground, anot=
her particular object, how much collision force is being applied to an o=
bject, etc. <strong>Note:</strong> This function only works if the conta=
ct graph is enabled either by enabling the sleeping feature of a space o=
r by enabling the contact graph. Sensor shapes and arbiters that have be=
en rejected by a collision handler callback or <code>cpArbiterIgnore()</=
code> are not tracked by the contact graph.</p>
<h2><a name=3D"cpBody-Integration Callbacks"></a><a href=3D"#cpBody-Inte=
gration Callbacks">Integration Callbacks:</a></h2>
<p>This section is a stub. For now you can look at the Planet demo for a=
n example of how to use integration callbacks to implement planetary gra=
vity.</p>
<p><!-- TODO document and examples --></p>
<h2><a name=3D"cpBody-Misc"></a><a href=3D"#cpBody-Misc">Misc Functions:=
</a></h2>
<ul>
	<li><code>cpBool cpBodyIsStatic(const cpBody *body)</code> &#8211; Retu=
rns true if <code>body</code> is a static body. Either <code>cpSpace.sta=
ticBody</code>, a body created with <code>cpBodyNewStatic()</code> or <c=
ode>cpBodyInitStatic()</code>.</li>
	<li><code>cpBool cpBodyIsRogue(const cpBody *body)</code> &#8211; Retur=
ns true if <code>body</code> has never been added to a space.</li>
</ul>
<h2><a name=3D"cpBody-Notes"></a><a href=3D"#cpBody-Notes">Notes:</a></h=
2>
<ul>
	<li>Use forces to modify the rigid bodies if possible. This will be the=
 most stable.</li>
	<li>Modifying a body&#8217;s velocity shouldn&#8217;t necessarily be av=
oided, but applying large changes every frame can cause strange results =
in the simulation. Experiment freely, but be warned.</li>
	<li><strong>Don&#8217;t</strong> modify a body&#8217;s position every s=
tep unless you really know what you are doing. Otherwise you&#8217;re li=
kely to get the position/velocity badly out of sync.</li>
	<li>If you free a body before calling <code>cpSpaceRemoveShape()</code>=
 on the shapes attached to it, you <strong>will</strong> cause crashes.<=
/li>
</ul>
<h1><a name=3D"cpShape"></a><a href=3D"#cpShape">Chipmunk Collision Shap=
es: <code>cpShape</code></a></h1>
<p>There are currently 3 collision shape types:</p>
<ul>
	<li><strong>Circles</strong>: Fastest and simplest collision shape.</li=
>
	<li><strong>Line segments</strong>: Meant mainly as a static shape. The=
y can be attached to moving bodies, but they don&#8217;t currently gener=
ate collisions with other line segments. Can be beveled in order to give=
 them a thickness.</li>
	<li><strong>Convex polygons</strong>: Slowest, but most flexible collis=
ion shape.</li>
</ul>
<p>You can add as many shapes to a body as you wish. That is why the two=
 types are separate. This should give you the flexibility to make any sh=
ape you want as well providing different areas of the same object with d=
ifferent friction, elasticity or callback values.</p>
<p>When creating different types of shapes, you will always be given a <=
code>cpShape*</code> pointer back. This is because Chipmunk shapes are m=
eant to be opaque types. Think of the specific collision types such as <=
code>cpCircleShape</code>, <code>cpSegmentShape</code> and <code>cpPolyS=
hape</code> as private subclasses of <code>cpShape</code>. You can still=
 read some properties from them using the getter functions, but you are =
not intended to cast <code>cpShape</code> pointers to their specific typ=
es.</p>
<h2><a name=3D"cpShape-Properties"></a><a href=3D"#cpShape-Properties">P=
roperties:</a></h2>
<p>Chipmunk provides getter/setter functions for a number of properties =
on collision shapes. Setting most properties automatically wakes the rig=
id body they are attached to up if it was sleeping. You can also set som=
e of the fields directly on the cpShape struct if you wish. They are doc=
umented in the headers.</p>
<pre><code>cpBody * cpShapeGetBody(const cpShape *shape)
void cpShapeSetBody(cpShape *shape, cpBody *body)</code></pre>
<p class=3D"expl">The rigid body the shape is attached to. Can only be s=
et when the shape is not added to a space.</p>
<pre><code>cpBB cpShapeGetBB(const cpShape *shape)</code></pre>
<p class=3D"expl">The bounding box of the shape. Only guaranteed to be v=
alid after <code>cpShapeCacheBB()</code> or <code>cpSpaceStep()</code> i=
s called. Moving a body that a shape is connected to does not update it&=
#8217;s bounding box. For shapes used for queries that aren&#8217;t atta=
ched to bodies, you can also use <code>cpShapeUpdate()</code>.</p>
<pre><code>cpBool cpShapeGetSensor(const cpShape *shape)
void cpShapeSetSensor(cpShape *shape, cpBool value)</code></pre>
<p class=3D"expl">A boolean value if this shape is a sensor or not. Sens=
ors only call collision callbacks, and never generate real collisions.</=
p>
<pre><code>cpFloat cpShapeGetElasticity(const cpShape *shape)
void cpShapeSetElasticity(cpShape *shape, cpFloat value)</code></pre>
<p class=3D"expl">Elasticity of the shape. A value of 0.0 gives no bounc=
e, while a value of 1.0 will give a &#8220;perfect&#8221; bounce. Howeve=
r due to inaccuracies in the simulation using 1.0 or greater is not reco=
mmended however. The elasticity for a collision is found by multiplying =
the elasticity of the individual shapes together.</p>
<pre><code>cpFloat cpShapeGetFriction(const cpShape *shape)
void cpShapeSetFriction(cpShape *shape, cpFloat value)</code></pre>
<p class=3D"expl">Friction coefficient. Chipmunk uses the Coulomb fricti=
on model, a value of 0.0 is frictionless. The friction for a collision i=
s found by multiplying the friction of the individual shapes together. <=
a href=3D"http://www.roymech.co.uk/Useful_Tables/Tribology/co_of_frict.h=
tm">Tables of friction coefficients</a>.</p>
<pre><code>cpVect cpShapeGetSurfaceVelocity(const cpShape *shape)
void cpShapeSetSurfaceVelocity(cpShape *shape, cpVect value)</code></pre=
>
<p class=3D"expl">The surface velocity of the object. Useful for creatin=
g conveyor belts or players that move around. This value is only used wh=
en calculating friction, not resolving the collision.</p>
<pre><code>cpCollisionType cpShapeGetCollisionType(const cpShape *shape)=

void cpShapeSetCollisionType(cpShape *shape, cpCollisionType value)</cod=
e></pre>
<p class=3D"expl">You can assign types to Chipmunk collision shapes that=
 trigger callbacks when objects of certain types touch. See the <a href=3D=
"#Callbacks-Handlers">callbacks section</a> for more information.</p>
<pre><code>cpGroup cpShapeGetGroup(const cpShape *shape)
void cpShapeSetGroup(cpShape *shape, cpGroup value)</code></pre>
<p class=3D"expl">Shapes in the same non-zero group do not generate coll=
isions. Useful when creating an object out of many shapes that you don&#=
8217;t want to self collide. Defaults to <code>CP_NO_GROUP</code>.</p>
<pre><code>cpLayers cpShapeGetLayers(const cpShape *shape)
void cpShapeSetLayers(cpShape *shape, cpLayers value)</code></pre>
<p class=3D"expl">Shapes only collide if they are in the same bit-planes=
. i.e. <code>(a-&gt;layers &amp; b-&gt;layers) !=3D 0</code> By default,=
 a shape occupies all bit-planes. <a href=3D"http://en.wikipedia.org/wik=
i/Mask_(computing)#top">Wikipedia</a> has a nice article on bitmasks if =
you are unfamiliar with how to use them. Defaults to <code>CP_ALL_LAYERS=
</code>.</p>
<pre><code>cpDataPointer cpShapeGetUserData(const cpShape *shape)
void cpShapeSetUserData(cpShape *shape, cpDataPointer value)</code></pre=
>
<p class=3D"expl">A user definable data pointer. If you set this to poin=
t at the game object the shapes is for, then you can access your game ob=
ject from Chipmunk callbacks.</p>
<h2><a name=3D"cpShape-Filtering"></a><a href=3D"#cpShape-Filtering">Fil=
tering Collisions:</a></h2>
<p>Chipmunk has two primary means of ignoring collisions: groups and lay=
ers.</p>
<p><strong>Groups</strong> are meant to ignore collisions between parts =
on a complex object. A ragdoll is a good example. When jointing an arm o=
nto the torso, you&#8217;ll want them to allow them to overlap. Groups a=
llow you to do exactly that. Shapes that have the same group don&#8217;t=
 generate collisions. So by placing all of the shapes in a ragdoll in th=
e same group, you&#8217;ll prevent it from colliding against other parts=
 of itself.</p>
<p><strong>Layers</strong> allow you to separate collision shapes into m=
utually exclusive planes. Shapes can be in more than one layer, and shap=
es only collide with other shapes that are in at least one of the same l=
ayers. As a simple example, say shape A is in layer 1, shape B is in lay=
er 2, and shape C is in layer 1 and 2. Shape A and B won&#8217;t collide=
 with each other, but shape C will collide with both A and B.</p>
<p>Layers can also be used to set up rule based collisions. Say you have=
 four types of shapes in your game. The player, the enemies, player bull=
ets and enemy bullets. The are that the player should collide with enemi=
es, and bullets shouldn&#8217;t collide with the type (player or enemy) =
that fired them. Making a chart would look like this:</p>
<table>
	<tr>
		<td> </td>
		<td> Player </td>
		<td> Enemy </td>
		<td> Player Bullet </td>
		<td> Enemy Bullet </td>
	</tr>
	<tr>
		<td> Player </td>
		<td> &#8211; </td>
		<td> (1) </td>
		<td>  </td>
		<td> (2) </td>
	</tr>
	<tr>
		<td> Enemy </td>
		<td> &#8211; </td>
		<td> &#8211; </td>
		<td> (3) </td>
		<td>  </td>
	</tr>
	<tr>
		<td> Player Bullet </td>
		<td> &#8211; </td>
		<td> &#8211; </td>
		<td> &#8211; </td>
		<td>  </td>
	</tr>
	<tr>
		<td> Enemy Bullet </td>
		<td> &#8211; </td>
		<td> &#8211; </td>
		<td> &#8211; </td>
		<td> &#8211; </td>
	</tr>
</table>
<p>The &#8216;-&#8217;s are for redundant spots in the chart, and the nu=
mbers are spots where types should collide. You can use a layer for each=
 rule that you want to define. Then add the layers to each type: The pla=
yer should be in layers 1 and 2, the enemy should be in layers 1 and 3, =
the player bullets should be in layer 3, and the enemy bullets should be=
 in layer 2. Treating layers as rules this way, you can define up to 32 =
rules. The default <code>cpLayers</code> type is <code>unsigned int</cod=
e> which has a resolution of 32 bits on most systems. You can redefine t=
he <code>cpLayers</code> type in <code>chipmunk_types.h</code> if you ne=
ed more bits to work with.</p>
<p>There is one last way of filtering collisions using collision handler=
s. See the <a href=3D"#Callbacks">section on callbacks</a> for more info=
rmation. While collision handlers can be more flexible, they are also th=
e slowest method. So you try to use groups or layers first.</p>
<h2><a name=3D"cpShape-Memory"></a><a href=3D"#cpShape-Memory">Memory Ma=
nagement Functions:</a></h2>

<pre><code>void cpShapeDestroy(cpShape *shape)
void cpShapeFree(cpShape *shape)</code></pre>
<p class=3D"expl"><code>Destroy</code> and <code>Free</code> functions a=
re shared by all shape types. Allocation and initialization functions ar=
e specific to each shape type. See below.</p>
<h2><a name=3D"cpShape-Misc"></a><a href=3D"#cpShape-Misc">Misc Function=
s:</a></h2>
<ul>
	<li><code>cpBB cpShapeCacheBB(cpShape *shape)</code> &#8211; Synchroniz=
es <code>shape</code> with the body its attached to.</li>
	<li><code>cpBB cpShapeUpdate(cpShape *shape, cpVect pos, cpVect rot)</c=
ode> &#8211; Sets the position and rotation of the shape to</li>
	<li><code>void cpResetShapeIdCounter(void)</code> &#8211; Chipmunk keep=
s a counter so that every new shape is given a unique hash value to be u=
sed in the spatial hash. Because this affects the order in which the col=
lisions are found and handled, you can reset the shape counter every tim=
e you populate a space with new shapes. If you don&#8217;t, there might =
be (very) slight differences in the simulation.</li>
</ul>
<h2><a name=3D"cpShape-Circles"></a><a href=3D"#cpShape-Circles">Working=
 With Circle Shapes:</a></h2>

<pre><code>cpCircleShape *cpCircleShapeAlloc(void)
cpCircleShape *cpCircleShapeInit(cpCircleShape *circle, cpBody *body, cp=
Float radius, cpVect offset)
cpShape *cpCircleShapeNew(cpBody *body, cpFloat radius, cpVect offset)</=
code></pre>
<p class=3D"expl"><code>body</code> is the body to attach the circle to,=
 <code>offset</code> is the offset from the body&#8217;s center of gravi=
ty in body local coordinates.</p>
<pre><code>cpVect cpCircleShapeGetOffset(cpShape *circleShape)
cpFloat cpCircleShapeGetRadius(cpShape *circleShape)</code></pre>
<p class=3D"expl">Getters for circle shape properties. Passing as non-ci=
rcle shape will throw an assertion.</p>
<h2><a name=3D"cpShape-Segments"></a><a href=3D"#cpShape-Segments">Worki=
ng With Segment Shapes:</a></h2>

<pre><code>cpSegmentShape* cpSegmentShapeAlloc(void)
cpSegmentShape* cpSegmentShapeInit(cpSegmentShape *seg, cpBody *body, cp=
Vect a, cpVect b, cpFloat radius)
cpShape* cpSegmentShapeNew(cpBody *body, cpVect a, cpVect b, cpFloat rad=
ius)</code></pre>
<p class=3D"expl"><code>body</code> is the body to attach the segment to=
, <code>a</code> and <code>b</code> are the endpoints, and <code>radius<=
/code> is the thickness of the segment.</p>
<pre><code>cpVect cpSegmentShapeGetA(cpShape *shape)
cpVect cpSegmentShapeGetA(cpShape *shape)
cpVect cpSegmentShapeGetNormal(cpShape *shape)
cpFloat cpSegmentShapeGetRadius(cpShape *shape)</code></pre>
<p class=3D"expl">Getters for segment shape properties. Passing a non-se=
gment shape will throw an assertion.</p>
<h2><a name=3D"cpShape-Polys"></a><a href=3D"#cpShape-Polys">Working Wit=
h Polygon Shapes:</a></h2>

<pre><code>cpPolyShape *cpPolyShapeAlloc(void)
cpPolyShape *cpPolyShapeInit(cpPolyShape *poly, cpBody *body, int numVer=
ts, cpVect *verts, cpVect offset)
cpShape *cpPolyShapeNew(cpBody *body, int numVerts, cpVect *verts, cpVec=
t offset)</code></pre>
<p class=3D"expl"><code>body</code> is the body to attach the poly to, <=
code>verts</code> is an array of <code>cpVect</code> structs defining a =
convex hull with a clockwise winding, <code>offset</code> is the offset =
from the body&#8217;s center of gravity in body local coordinates. An as=
sertion will be thrown the vertexes are not convex or do not have a cloc=
kwise winding.</p>
<pre><code>int cpPolyShapeGetNumVerts(cpShape *shape)
cpVect cpPolyShapeGetVert(cpShape *shape, int index)</code></pre>
<p class=3D"expl">Getters for poly shape properties. Passing a non-poly =
shape or an index that does not exist will throw an assertion.</p>
<h3><a name=3D"cpShape-Polys-Boxes"></a><a href=3D"#cpShape-Polys-Boxes"=
>Boxes:</a></h3>
<p>Because boxes are so common in physics games, Chipmunk provides short=
cuts to create box shaped polygons. The boxes will always be centered at=
 the center of gravity of the body you are attaching them to. If you wan=
t to create an off-center box, you will need to use <code>cpPolyShapeNew=
()</code> or <code>cpPolyShapeInit()</code>.</p>
<pre><code>cpPolyShape *cpBoxShapeInit(cpPolyShape *poly, cpBody *body, =
cpFloat width, cpFloat height)
cpShape *cpBoxShapeNew(cpBody *body, cpFloat width, cpFloat height)</cod=
e></pre>
<h3><a name=3D"cpShape-Polys-PolyHelpers"></a><a href=3D"#cpShape-Polys-=
PolyHelpers">Poly Shape Helper Functions:</a></h3>
<ul>
	<li><code>cpBool cpPolyValidate(const cpVect *verts, const int numVerts=
)</code> &#8211; Check if a vertex array is convex and with the correct =
winding.</li>
	<li><code>cpVect cpCentroidForPoly(const int numVerts, const cpVect *ve=
rts)</code> &#8211; Calculate the centroid for a polygon.</li>
	<li><code>void cpRecenterPoly(const int numVerts, cpVect *verts)</code>=
 &#8211; Center a polygon to (0,0). Subtracts the centroid from each ver=
tex.</li>
</ul>
<h2><a name=3D"cpShape-Modifing"></a><a href=3D"#cpShape-Modifing">Modif=
ying cpShapes:</a></h2>
<p>The short answer is that you can&#8217;t because the changes would be=
 only picked up as a change to the position of the shape&#8217;s surface=
, but not it&#8217;s velocity. The long answer is that you can using the=
 &#8220;unsafe&#8221; <span class=3D"caps">API</span> as long as you rea=
lize that doing so will not result in realistic physical behavior. These=
 extra functions are defined in a separate header <code>chipmunk_unsafe.=
h</code>.</p>
<h2><a name=3D"cpShape-Notes"></a><a href=3D"#cpShape-Notes">Notes:</a><=
/h2>
<ul>
	<li>You can attach multiple collision shapes to a rigid body. This shou=
ld allow you to create almost any shape you could possibly need.</li>
	<li>Shapes attached to the same rigid body will never generate collisio=
ns. You don&#8217;t have to worry about overlap when attaching multiple =
shapes to a rigid body.</li>
	<li>Make sure you add both the body and it&#8217;s collision shapes to =
a space. The exception is when you want to have an externally body or a =
body that you integrate yourself. In that case, only add the shape.</li>=

</ul>
<h1><a name=3D"cpSpace"></a><a href=3D"#cpSpace">Chipmunk Spaces: <code>=
cpSpace</code></a></h1>
<p>Spaces in Chipmunk are the basic unit of simulation. You add rigid bo=
dies, shapes and constraints to it and then step them all forward throug=
h time together.</p>
<h2><a name=3D"cpSpace-Iterations"></a><a href=3D"#cpSpace-Iterations">W=
hat Are Iterations, and Why Should I care?</a></h2>
<p>Chipmunk uses an iterative solver to figure out the forces between ob=
jects in the space. What this means is that it builds a big list of all =
of the collisions, joints, and other constraints between the bodies and =
makes several passes over the list considering each one individually. Th=
e number of passes it makes is the iteration count, and each iteration m=
akes the solution more accurate. If you use too many iterations, the phy=
sics should look nice and solid, but may use up too much <span class=3D"=
caps">CPU</span> time. If you use too few iterations, the simulation may=
 seem mushy or bouncy when the objects should be solid. Setting the numb=
er of iterations lets you balance between <span class=3D"caps">CPU</span=
> usage and the accuracy of the physics. Chipmunk&#8217;s default of 10 =
iterations is sufficient for most simple games.</p>
<h2><a name=3D"cpSpace-Sleeping"></a><a href=3D"#cpSpace-Sleeping">Sleep=
ing</a></h2>
<p>New in Chipmunk 5.3 is the ability of spaces to disable entire groups=
 of objects that have stopped moving to save <span class=3D"caps">CPU</s=
pan> time as well as battery life. In order to use this feature you must=
 do 2 things. The first is that you must attach all your static geometry=
 to static bodies. Objects cannot fall asleep if they are touching a non=
-static rogue body even if it&#8217;s shapes were added as static shapes=
. The second is that you must enable sleeping explicitly by choosing a t=
ime threshold value for <code>cpSpace.sleepTimeThreshold</code>. If you =
do not set <code>cpSpace.idleSpeedThreshold</code> explicitly, a value w=
ill be chosen automatically based on the current amount of gravity.</p>
<h2><a name=3D"cpSpace-Properties"></a><a href=3D"#cpSpace-Properties">P=
roperties:</a></h2>

<pre><code>int cpSpaceGetIterations(const cpSpace *space)
void cpSpaceSetIterations(cpSpace *space, int value)</code></pre>
<p class=3D"expl">Iterations allow you to control the accuracy of the so=
lver. Defaults to 10. See <a href=3D"#cpSpace-Iterations">above</a> for =
more information.</p>
<pre><code>cpVect cpSpaceGetGravity(const cpSpace *space)
void cpSpaceSetGravity(cpSpace *space, cpVect value)</code></pre>
<p class=3D"expl">Global gravity applied to the space. Defaults to <code=
>cpvzero</code>. Can be overridden on a per body basis by writing custom=
 integration functions.</p>
<pre><code>cpFloat cpSpaceGetDamping(const cpSpace *space)
void cpSpaceSetDamping(cpSpace *space, cpFloat value)</code></pre>
<p class=3D"expl">Amount of simple damping to apply to the space. A valu=
e of 0.9 means that each body will lose 10% of it&#8217;s velocity per s=
econd. Defaults to 1. Like <code>gravity</code> can be overridden on a p=
er body basis.</p>
<pre><code>cpFloat cpSpaceGetIdleSpeedThreshold(const cpSpace *space)
void cpSpaceSetIdleSpeedThreshold(cpSpace *space, cpFloat value)</code><=
/pre>
<p class=3D"expl">Speed threshold for a body to be considered idle. The =
default value of 0 means to let the space guess a good threshold based o=
n gravity.</p>
<pre><code>cpFloat cpSpaceGetSleepTimeThreshold(const cpSpace *space)
void cpSpaceSetSleepTimeThreshold(cpSpace *space, cpFloat value)</code><=
/pre>
<p class=3D"expl">Time a group of bodies must remain idle in order to fa=
ll asleep. The default value of <code>INFINITY</code> disables the sleep=
ing feature.</p>
<pre><code>cpFloat cpSpaceGetCollisionSlop(const cpSpace *space)
void cpSpaceSetCollisionSlop(cpSpace *space, cpFloat value)</code></pre>=

<p class=3D"expl">Amount of overlap between shapes that is allowed. It&#=
8217;s encouraged to set this as high as you can without noticable overl=
apping as it improves the stability. It defaults to 0.1.</p>
<pre><code>cpFloat cpSpaceGetCollisionBias(const cpSpace *space)
void cpSpaceSetCollisionBias(cpSpace *space, cpFloat value)</code></pre>=

<p class=3D"expl">Chipmunk allows fast moving objects to overlap, then f=
ixes the overlap over time. Overlapping objects are unavoidable even if =
swept collisions are supported, and this is an efficient and stable way =
to deal with overlapping objects. The bias value controls what percentag=
e of overlap remains unfixed after a second and defaults to ~0.2%. Valid=
 values are in the range from 0 to 1, but using 0 is not recommended for=
 stability reasons. The default value is calculated as <code>cpfpow(1.0f=
 - 0.1f, 60.0f)</code> meaning that Chipmunk attempts to correct 10% of =
error ever 1/60th of a second. <strong>Note:</strong> Very very few game=
s will need to change this value.</p>
<pre><code>cpTimestamp cpSpaceGetCollisionPersistence(const cpSpace *spa=
ce)
void cpSpaceSetCollisionPersistence(cpSpace *space, cpTimestamp value)</=
code></pre>
<p class=3D"expl">The number of frames the space keeps collision solutio=
ns around for. Helps prevent jittering contacts from getting worse. This=
 defaults to 3 and very very <em>very</em> few games will need to change=
 this value.</p>
<pre><code>cpBool cpSpaceGetEnableContactGraph(const cpSpace *space)
void cpSpaceSetEnableContactGraph(cpSpace *space, cpBool value)</code></=
pre>
<p class=3D"expl">In order to use the <code>cpBodyEachArbiter()</code> f=
unction, you must tell Chipmunk to generate the contact graph. Disabled =
by default as it incurrs a small 5-10% overhead. Enabling the sleeping f=
eature also enables the contact graph.</p>
<pre><code>cpFloat cpSpaceGetCurrentTimeStep(const cpSpace *space)</code=
></pre>
<p class=3D"expl">Retrieves the current (if you are in a callback from <=
code>cpSpaceStep()</code>) or most recent (outside of a <code>cpSpaceSte=
p()</code> call) timestep.</p>
<pre><code>cpFloat cpSpaceIsLocked(const cpSpace *space)</code></pre>
<p class=3D"expl">Returns true when in a callback meaning that you canno=
t add/remove objects from the space. Can be used to choose to create a p=
ost-step callback instead.</p>
<pre><code>cpDataPointer cpSpaceGetUserData(const cpSpace *space)
void cpSpaceSetUserData(cpSpace *space, cpDataPointer value)</code></pre=
>
<p class=3D"expl">A user definable data pointer. It&#8217;s useful to po=
int this at the gamestate object or scene management object that owns th=
e space.</p>
<pre><code>cpBody * cpSpaceGetStaticBody(const cpSpace *space)</code></p=
re>
<p class=3D"expl">A dedicated static body for the space. You don&#8217;t=
 have to use it, but because it&#8217;s memory is managed automatically =
with the space it&#8217;s very convenient. You can set its user data poi=
nter to something helpful if you want for callbacks.</p>
<h2><a name=3D"cpSpace-Memory"></a><a href=3D"#cpSpace-Memory">Memory Ma=
nagement Functions:</a></h2>

<pre><code>cpSpace* cpSpaceAlloc(void)
cpSpace* cpSpaceInit(cpSpace *space)
cpSpace* cpSpaceNew()

void cpSpaceDestroy(cpSpace *space)
void cpSpaceFree(cpSpace *space)</code></pre>
<p class=3D"expl">More standard Chipmunk memory functions.</p>
<pre><code>void cpSpaceFreeChildren(cpSpace *space)</code></pre>
<p class=3D"expl">This function will free all of the shapes, bodies and =
joints that have been added to <code>space</code>. Does not free <code>s=
pace</code>. You will still need to call <code>cpSpaceFree()</code> on y=
our own. You will probably never use this in a real game, as your gamest=
ate or game controller should manage removing and freeing objects from t=
he space.</p>
<h2><a name=3D"cpSpace-Operations"></a><a href=3D"#cpSpace-Operations">O=
perations:</a></h2>

<pre><code>cpShape *cpSpaceAddShape(cpSpace *space, cpShape *shape)
cpShape *cpSpaceAddStaticShape(cpSpace *space, cpShape *shape)
cpBody *cpSpaceAddBody(cpSpace *space, cpBody *body)
cpConstraint *cpSpaceAddConstraint(cpSpace *space, cpConstraint *constra=
int)

void cpSpaceRemoveShape(cpSpace *space, cpShape *shape)
void cpSpaceRemoveBody(cpSpace *space, cpBody *body)
void cpSpaceRemoveConstraint(cpSpace *space, cpConstraint *constraint)

cpBool cpSpaceContainsShape(cpSpace *space, cpShape *shape)
cpBool cpSpaceContainsBody(cpSpace *space, cpBody *body)
cpBool cpSpaceContainsConstraint(cpSpace *space, cpConstraint *constrain=
t)</code></pre>
<p class=3D"expl">These functions add and remove shapes, bodies and cons=
traints from <code>space</code>. The add/remove functions cannot be call=
ed from within a callback other than a <code>postStep()</code> callback =
<em>(which is different than a postSolve() callback!)</em>. Attempting t=
o add or remove objects from the space while <code>cpSpaceStep()</code> =
is still executing will throw an assertion. See the <a href=3D"#Callback=
s">callbacks section</a> for more information. The add functions return =
the thing being added so that you can create and add something in one li=
ne. Be careful not to free bodies before removing shapes and constraints=
 attached to them or you will cause crashes.. The contains functions all=
ow you to check if an object has been added to the space or not.</p>
<h3><a name=3D"cpSpace-Operations-Deprecated"></a><a href=3D"#cpSpace-Op=
erations-Deprecated">Deprecated:</a></h3>

<pre><code>cpShape *cpSpaceAddStaticShape(cpSpace *space, cpShape *shape=
)
void cpSpaceRemoveStaticShape(cpSpace *space, cpShape *shape)</code></pr=
e>
<p class=3D"expl">Shapes attached to static bodies are automatically tre=
ated as static. There isn&#8217;t really a good reason to explicitly add=
 static shapes anymore.</p>
<ul>
	<li><code>void cpSpaceActivateShapesTouchingShape(cpSpace *space, cpSha=
pe *shape)</code> &#8211; Use <code>cpBodyActivateStatic()</code> instea=
d.</li>
</ul>
<h2><a name=3D"cpSpace-SpatialIndexing"></a><a href=3D"#cpSpace-SpatialI=
ndexing">Spatial Indexing:</a></h2>
<p>Chipmunk 6 officially supports 2 spatial indexes. The default is an a=
xis-aligned bounding box tree inspired by the one used in the Bullet Phy=
sics library, but extended with my own collision pair caching to give th=
e tree very good temporal coherence. The tree requires no tuning, and mo=
st games will find that they get much better performance using it. The o=
ther available index available is a spatial hash, which can be much fast=
er when you have a very large number (1000s) of objects that are all the=
 same size.</p>
<p>Occasionally, you might want to update the collision detection data f=
or a shape. If you move a static shape or a static body you <strong>must=
</strong> do this to let Chipmunk know it needs to have it&#8217;s colli=
sion detection data updated. You may also want to manually update the co=
llision data for normal shapes if you move them and still want to perfor=
m queries.</p>
<ul>
	<li><code>void cpSpaceReindexShape(cpSpace *space, cpShape *shape)</cod=
e> &#8211; Reindex a specific shape.</li>
	<li><code>void cpSpaceReindexShapesForBody(cpSpace *space, cpBody *body=
)</code> &#8211; Reindex all the shapes for a certain body.</li>
	<li><code>void cpSpaceReindexStatic(cpSpace *space)</code> &#8211; Rein=
dex all static shapes. Generally updating only the shapes that changed i=
s faster.</li>
</ul>
<h2><a name=3D"cpSpace-Iterators"></a><a href=3D"#cpSpace-Iterators">Ite=
rators:</a></h2>

<pre><code>typedef void (*cpSpaceBodyIteratorFunc)(cpBody *body, void *d=
ata)
void cpSpaceEachBody(cpSpace *space, cpSpaceBodyIteratorFunc func, void =
*data)</code></pre>
<p class=3D"expl">Call <code>func</code> for each body in the space also=
 passing along your data pointer. Sleeping bodies are included, but stat=
ic and rogue bodies are not as they aren&#8217;t added to the space.</p>=

<div><a class=3D"HideShow" href=3D"javascript:;" onmousedown=3D"toggleEx=
ample('Pop Open cpSpaceEachBody Example', 'examples/cpSpaceEachBody.html=
');">Hide/Show cpSpaceEachBody Example</a><div id=3D"Pop Open cpSpaceEac=
hBody Example" style=3D"display:none"></div></div>
<pre><code>typedef void (*cpSpaceShapeIteratorFunc)(cpShape *shape, void=
 *data)
void cpSpaceEachShape(cpSpace *space, cpSpaceShapeIteratorFunc func, voi=
d *data)</code></pre>
<p class=3D"expl">Call <code>func</code> for each shape in the space als=
o passing along your data pointer. Sleeping and static shapes are includ=
ed.</p>
<pre><code>typedef void (*cpSpaceConstraintIteratorFunc)(cpConstraint *c=
onstraint, void *data)
void cpSpaceEachConstraint(cpSpace *space, cpSpaceConstraintIteratorFunc=
 func, void *data)</code></pre>
<p class=3D"expl">Call <code>func</code> for each constraint in the spac=
e also passing along your data pointer.</p>
<h2><a name=3D"cpSpace-Simulating"></a><a href=3D"#cpSpace-Simulating">S=
imulating the Space:</a></h2>

<pre><code>void cpSpaceStep(cpSpace *space, cpFloat dt)</code></pre>
<p class=3D"expl">Update the space for the given time step. Using a fixe=
d time step is <em>highly</em> recommended. Doing so can greatly increas=
e the quality of the simulation. The easiest way to do constant timestep=
s is to simple step forward by 1/60th of a second (or whatever your targ=
et framerate is) for each frame regardless of how long it took to render=
. This works fine for many games, but a better way to do it is to separa=
te your physics timestep and rendering. <a href=3D"http://gafferongames.=
com/game-physics/fix-your-timestep/">This</a> is a good article on how t=
o do that.</p>
<h2><a name=3D"cpSpace-SpatialHash"></a><a href=3D"#cpSpace-SpatialHash"=
>Enabling and Tuning the Spatial Hash:</a></h2>
<p>If you have thousands of objects that are all approximately the same =
size, the spatial hash may be for you.</p>
<pre><code>void cpSpaceUseSpatialHash(cpSpace *space, cpFloat dim, int c=
ount)</code></pre>
<p class=3D"expl">Switch the space to use a spatial hash instead of the =
bounding box tree.</p>
<p>The spatial hash data is fairly size sensitive. <code>dim</code> is t=
he size of the hash cells. Setting <code>dim</code> to the average colli=
sion shape size is likely to give the best performance. Setting <code>di=
m</code> too small will cause the shape to be inserted into many cells, =
setting it too low will cause too many objects into the same hash slot.<=
/p>
<p><code>count</code> is the <em>suggested</em> minimum number of cells =
in the hash table. If there are too few cells, the spatial hash will ret=
urn many false positives. Too many cells will be hard on the cache and w=
aste memory. the  Setting <code>count</code> to ~10x the number of objec=
ts in the space is probably a good starting point. Tune from there if ne=
cessary.</p>
<p>Using the spatial has visualization in the demo program you can see w=
hat I mean. The grey squares represent cells in the spatial hash. The da=
rker the cell, the more objects have been mapped into that cell. A good =
<code>dim</code> size is when your objects fit nicely into the grid:</p>=

<p><img src=3D"images/hash_just_right.png" alt=3D"" /></p>
<p>Notice the light grey meaning that each cell doesn&#8217;t have too m=
any objects mapped onto it.</p>
<p>When you use too small a size, Chipmunk has to insert each object int=
o a lot of cells. This can get expensive.</p>
<p><img src=3D"images/hash_too_small.png" alt=3D"" /></p>
<p>Notice that the grey cells are very small compared to the collision s=
hapes.</p>
<p>When you use too big of a size, a lot of shapes will fit into each ce=
ll. Each shape has to be checked against every other shape in the cell, =
so this makes for a lot of unnecessary collision checks.</p>
<p><img src=3D"images/hash_too_big.png" alt=3D"" /></p>
<p>Notice the dark grey cells meaning that many objects are mapped onto =
them.</p>
<p>Chipmunk 6 also has an experimental single axis sort and sweep implem=
entation. It can be very efficient on mobile games if your world is very=
 long and flat like a racing game. See the code for <code>cpSpaceUseSpat=
ialHash()</code> if you want to try enabling it.</p>
<h2><a name=3D"cpSpace-Notes"></a><a href=3D"#cpSpace-Notes">Notes:</a><=
/h2>
<ul>
	<li>When removing objects from the space, make sure you remove any othe=
r objects that reference it. For instance, when you remove a body, remov=
e the joints and shapes attached to it.</li>
	<li>The number of iterations, and the size of the time step determine t=
he quality of the simulation. More iterations, or smaller time steps inc=
rease the quality. Keep in mind that higher quality also means higher <s=
pan class=3D"caps">CPU</span> usage.</li>
	<li>Because static shapes are only rehashed when you request it, it&#82=
17;s possible to use a much higher <code>count</code> argument to <code>=
cpHashResizeStaticHash()</code> than to <code>cpSpaceResizeActiveHash()<=
/code>. Doing so will use more memory but can improve performance if you=
 have a lot of static shapes.</li>
</ul>
<h1><a name=3D"cpConstraint"></a><a href=3D"#cpConstraint">Chipmunk Cons=
traints: <code>cpConstraint</code></a></h1>
<p>A constraint is something that describes how two bodies interact with=
 each other. (how they constrain each other) Constraints can be simple j=
oints that allow bodies to pivot around each other like the bones in you=
r body, or they can be more abstract like the gear joint or motors.</p>
<h2><a name=3D"cpConstraint-WhatIs"></a><a href=3D"#cpConstraint-WhatIs"=
>What constraints are and what they are not:</a></h2>
<p>Constraints in Chipmunk are all velocity based constraints. This mean=
s that they act primarily by synchronizing the velocity of two bodies. A=
 pivot joint holds two anchor points on two separate bodies together by =
defining equations that say that the velocity of the anchor points must =
be the same and calculating impulses to apply to the bodies to try and k=
eep it that way. A constraint takes a velocity as it&#8217;s primary inp=
ut and produces a velocity change as it&#8217;s output. Some constraints=
, (joints in particular) apply velocity changes to correct differences i=
n positions. More about this in the next section.</p>
<p>A spring connected between two bodies is not a constraint. It&#8217;s=
 very constraint-like as it creates forces that affect the velocities of=
 the two bodies, but a spring takes distances as input and produces forc=
es as it&#8217;s output. If a spring is not a constraint, then why do I =
have two varieties of spring constraints you ask? The reason is because =
they are <em>damped springs</em>. The damping associated with the spring=
 is a true constraint that creates velocity changes based on the relativ=
e velocities of the two bodies it links. As it is convenient to put a da=
mper and a spring together most of the time, I figured I might as well j=
ust apply the spring force as part of the constraint instead of having a=
 damper constraint and having the user calculate and apply their own spr=
ing forces separately.</p>
<h2><a name=3D"cpConstraint-Properties"></a><a href=3D"#cpConstraint-Pro=
perties">Properties:</a></h2>

<pre><code>cpBody * cpConstraintGetA(const cpConstraint *constraint)
cpBody * cpConstraintGetB(const cpConstraint *constraint)</code></pre>
<p class=3D"expl">Getters for the two bodies the constraint is attached =
to.</p>
<pre><code>cpFloat cpConstraintGetMaxForce(const cpConstraint *constrain=
t)
void cpConstraintSetMaxForce(cpConstraint *constraint, cpFloat value)</c=
ode></pre>
<p class=3D"expl">The maximum force that the constraint can use to act o=
n the two bodies. Defaults to <span class=3D"caps">INFINITY</span>.</p>
<pre><code>cpFloat cpConstraintGetErrorBias(const cpConstraint *constrai=
nt)
void cpConstraintSetErrorBias(cpConstraint *constraint, cpFloat value)</=
code></pre>
<p class=3D"expl">The percentage of joint error that remains unfixed aft=
er a second. This works exactly the same as the collision bias property =
of a space, but applies to fixing error (stretching) of joints instead o=
f overlapping collisions.</p>
<pre><code>cpFloat cpConstraintGetMaxBias(const cpConstraint *constraint=
)
void cpConstraintSetMaxBias(cpConstraint *constraint, cpFloat value)</co=
de></pre>
<p class=3D"expl">The maximum speed at which the constraint can apply er=
ror correction. Defaults to <span class=3D"caps">INFINITY</span>.</p>
<pre><code>cpDataPointer cpConstraintGetUserData(const cpConstraint *con=
straint)
void cpConstraintSetUserData(cpConstraint *constraint, cpDataPointer val=
ue)</code></pre>
<p class=3D"expl">User data pointer. Use this pointer to get a reference=
 to the game object that owns this constraint from callbacks.</p>
<pre><code>cpFloat cpConstraintGetImpulse(cpConstraint *constraint)</cod=
e></pre>
<p class=3D"expl">The most recent impulse that <code>constraint</code> a=
pplied. To convert this to a force, divide by the timestep passed to <co=
de>cpSpaceStep()</code>. You can use this to implement breakable joints =
to check if the force they attempted to apply exceeded a certain thresho=
ld.</p>
<div><a class=3D"HideShow" href=3D"javascript:;" onmousedown=3D"toggleEx=
ample('Pop Open BreakableJoint Example', 'examples/BreakableJoint.html')=
;">Hide/Show BreakableJoint Example</a><div id=3D"Pop Open BreakableJoin=
t Example" style=3D"display:none"></div></div>
<p>To access properties of specific joint types, use the getter and sett=
er functions provided (ex: <code>cpPinJointGetAnchr1()</code>). See the =
lists of properties for more information.</p>
<h2><a name=3D"cpConstraint-ErrorCorrection"></a><a href=3D"#cpConstrain=
t-ErrorCorrection">Error correction by Feedback:</a></h2>
<p>Joints in Chipmunk are not perfect. A pin joint can&#8217;t maintain =
the exact correct distance between it&#8217;s anchor points, nor can a p=
ivot joint hold it&#8217;s anchor points completely together. Instead, t=
hey are designed to deal with this by correcting themselves over time. I=
n Chipmunk 5, you have a fair amount of extra control over how joints co=
rrect themselves and can even use this ability to create physical effect=
s that allow you to use joints in unique ways:</p>
<ul>
	<li>Servo motors &#8211; Ex: open/close doors or rotate things without =
going over a maximum force.</li>
	<li>Winches &#8211; Pull one object towards another at a constant speed=
 without going over a maximum force.</li>
	<li>Mouse manipulation &#8211; Interact with objects smoothly given coa=
rse/shaky mouse input.</li>
</ul>
<p>There are three properties of cpConstraint structs that control the e=
rror correction, <code>maxForce</code>, <code>maxBias</code>, and <code>=
biasCoef</code>. <code>maxForce</code> is pretty self explanatory, a joi=
nt or constraint will not be able to use more than this amount of force =
in order to function. If it needs more force to be able to hold itself t=
ogether, it will fall apart. <code>maxBias</code> is the maximum speed a=
t which error correction can be applied. If you change a property on a j=
oint so that the joint will have to correct itself, it normally does so =
very quickly. By setting a maxSpeed you can make the joint work like a s=
ervo, correcting itself at a constant rate over a longer period of time.=
 Lastly, <code>biasCoef</code> is the percentage of error corrected ever=
y step before clamping to a maximum speed. You can use this to make join=
ts correct themselves smoothly instead of at a constant speed, but is pr=
obably the least useful of the three properties by far.</p>
<p><!-- TODO more examples --></p>
<div><a class=3D"HideShow" href=3D"javascript:;" onmousedown=3D"toggleEx=
ample('Pop Open JointRecipies Example', 'examples/JointRecipies.html');"=
>Hide/Show JointRecipies Example</a><div id=3D"Pop Open JointRecipies Ex=
ample" style=3D"display:none"></div></div>
<h2><a name=3D"cpConstraint-Shapes"></a><a href=3D"#cpConstraint-Shapes"=
>Constraints and Collision Shapes:</a></h2>
<p>Neither constraints or collision shapes have any knowledge of the oth=
er. When connecting joints to a body the anchor points don&#8217;t need =
to be inside of any shapes attached to the body and it often makes sense=
 that they shouldn&#8217;t. Also, adding a constraint between two bodies=
 doesn&#8217;t prevent their collision shapes from colliding. In fact, t=
his is the primary reason that the collision group property exists.</p>
<h2><a name=3D"cpConstraint-Video"></a><a href=3D"#cpConstraint-Video">V=
ideo Tour of Current Joint Types. (Requires connection to YouTube)</a></=
h2>
<p><object width=3D"425" height=3D"344"><param name=3D"movie" value=3D"h=
ttp://www.youtube.com/v/ZgJJZTS0aMM&amp;hl=3Den_US&amp;fs=3D1?rel=3D0"><=
/param><param name=3D"allowFullScreen" value=3D"true"></param><param nam=
e=3D"allowscriptaccess" value=3D"always"></param><embed src=3D"http://ww=
w.youtube.com/v/ZgJJZTS0aMM&amp;hl=3Den_US&amp;fs=3D1?rel=3D0" type=3D"a=
pplication/x-shockwave-flash" allowscriptaccess=3D"always" allowfullscre=
en=3D"true" width=3D"425" height=3D"344"></embed></object></p>
<h2><a name=3D"cpConstraint-Memory"></a><a href=3D"#cpConstraint-Memory"=
>Shared Memory Management Functions:</a></h2>

<pre><code>void cpConstraintDestroy(cpConstraint *constraint)
void cpConstraintFree(cpConstraint *constraint)</code></pre>
<p class=3D"expl"><code>Destroy</code> and <code>Free</code> functions a=
re shared by all joint types. Allocation and initialization functions ar=
e specific to each joint type.</p>
<h1><a name=3D"ConstraintTypes"></a><a href=3D"#ConstraintTypes">Constra=
int Types:</a></h1>
<h2><a name=3D"ConstraintTypes-cpPinJoint"></a><a href=3D"#ConstraintTyp=
es-cpPinJoint">Pin Joints:</a></h2>

<pre><code>cpPinJoint *cpPinJointAlloc(void)
cpPinJoint *cpPinJointInit(cpPinJoint *joint, cpBody *a, cpBody *b, cpVe=
ct anchr1, cpVect anchr2)
cpConstraint *cpPinJointNew(cpBody *a, cpBody *b, cpVect anchr1, cpVect =
anchr2)</code></pre>
<p class=3D"expl"><code>a</code> and <code>b</code> are the two bodies t=
o connect, and <code>anchr1</code> and <code>anchr2</code> are the ancho=
r points on those bodies. The distance between the two anchor points is =
measured when the joint is created. If you want to set a specific distan=
ce, use the setter function to override it.</p>
<h3><a name=3D"ConstraintTypes-cpPinJoint-Properties"></a><a href=3D"#Co=
nstraintTypes-cpPinJoint-Properties">Properties</a></h3>
<ul>
	<li><code>cpVect cpPinJointGetAnchr1(const cpConstraint *constraint)</c=
ode></li>
	<li><code>void cpPinJointSetAnchr1(cpConstraint *constraint, cpVect val=
ue)</code></li>
	<li><code>cpVect cpPinJointGetAnchr2(const cpConstraint *constraint)</c=
ode></li>
	<li><code>void cpPinJointSetAnchr2(cpConstraint *constraint, cpVect val=
ue)</code></li>
	<li><code>cpFloat cpPinJointGetDist(const cpConstraint *constraint)</co=
de></li>
	<li><code>void cpPinJointSetDist(cpConstraint *constraint, cpFloat valu=
e)</code></li>
</ul>
<h2><a name=3D"ConstraintTypes-cpSlideJoint"></a><a href=3D"#ConstraintT=
ypes-cpSlideJoint">Slide Joints:</a></h2>

<pre><code>cpSlideJoint *cpSlideJointAlloc(void)

cpSlideJoint *cpSlideJointInit(
	cpSlideJoint *joint, cpBody *a, cpBody *b,
	cpVect anchr1, cpVect anchr2, cpFloat min, cpFloat max
)

cpConstraint *cpSlideJointNew(cpBody *a, cpBody *b, cpVect anchr1, cpVec=
t anchr2, cpFloat min, cpFloat max)</code></pre>
<p class=3D"expl"><code>a</code> and <code>b</code> are the two bodies t=
o connect, <code>anchr1</code> and <code>anchr2</code> are the anchor po=
ints on those bodies, and <code>min</code> and <code>max</code> define t=
he allowed distances of the anchor points.</p>
<h3><a name=3D"ConstraintTypes-cpSlideJoint-Properties"></a><a href=3D"#=
ConstraintTypes-cpSlideJoint-Properties">Properties</a></h3>
<ul>
	<li><code>cpVect cpSlideJointGetAnchr1(const cpConstraint *constraint)<=
/code></li>
	<li><code>void cpSlideJointSetAnchr1(cpConstraint *constraint, cpVect v=
alue)</code></li>
	<li><code>cpVect cpSlideJointGetAnchr2(const cpConstraint *constraint)<=
/code></li>
	<li><code>void cpSlideJointSetAnchr2(cpConstraint *constraint, cpVect v=
alue)</code></li>
	<li><code>cpFloat cpSlideJointGetMin(const cpConstraint *constraint)</c=
ode></li>
	<li><code>void cpSlideJointSetMin(cpConstraint *constraint, cpFloat val=
ue)</code></li>
	<li><code>cpFloat cpSlideJointGetMax(const cpConstraint *constraint)</c=
ode></li>
	<li><code>void cpSlideJointSetMax(cpConstraint *constraint, cpFloat val=
ue)</code></li>
</ul>
<h2><a name=3D"ConstraintTypes-cpPivotJoint"></a><a href=3D"#ConstraintT=
ypes-cpPivotJoint">Pivot Joints:</a></h2>

<pre><code>cpPivotJoint *cpPivotJointAlloc(void)
cpPivotJoint *cpPivotJointInit(cpPivotJoint *joint, cpBody *a, cpBody *b=
, cpVect pivot)
cpConstraint *cpPivotJointNew(cpBody *a, cpBody *b, cpVect pivot)
cpConstraint *cpPivotJointNew2(cpBody *a, cpBody *b, cpVect anchr1, cpVe=
ct anchr2)</code></pre>
<p class=3D"expl"><code>a</code> and <code>b</code> are the two bodies t=
o connect, and <code>pivot</code> is the point in world coordinates of t=
he pivot. Because the pivot location is given in world coordinates, you =
must have the bodies moved into the correct positions already. Alternati=
vely you can specify the joint based on a pair of anchor points, but mak=
e sure you have the bodies in the right place as the joint will fix itse=
lf as soon as you start simulating the space.</p>
<h3><a name=3D"ConstraintTypes-cpPivotJoint-Properties"></a><a href=3D"#=
ConstraintTypes-cpPivotJoint-Properties">Properties</a></h3>
<ul>
	<li><code>cpVect cpPivotJointGetAnchr1(const cpConstraint *constraint)<=
/code></li>
	<li><code>void cpPivotJointSetAnchr1(cpConstraint *constraint, cpVect v=
alue)</code></li>
	<li><code>cpVect cpPivotJointGetAnchr2(const cpConstraint *constraint)<=
/code></li>
	<li><code>void cpPivotJointSetAnchr2(cpConstraint *constraint, cpVect v=
alue)</code></li>
</ul>
<h2><a name=3D"ConstraintTypes-cpGrooveJoint"></a><a href=3D"#Constraint=
Types-cpGrooveJoint">Groove Joint:</a></h2>

<pre><code>cpGrooveJoint *cpGrooveJointAlloc(void)

cpGrooveJoint *cpGrooveJointInit(
	cpGrooveJoint *joint, cpBody *a, cpBody *b,
	cpVect groove_a, cpVect groove_b, cpVect anchr2
)

cpConstraint *cpGrooveJointNew(cpBody *a, cpBody *b, cpVect groove_a, cp=
Vect groove_b, cpVect anchr2)</code></pre>
<p class=3D"expl">The groove goes from <code>groov_a</code> to <code>gro=
ove_b</code> on body <code>a</code>, and the pivot is attached to <code>=
anchr2</code> on body <code>b</code>. All coordinates are body local.</p=
>
<h3><a name=3D"ConstraintTypes-cpGrooveJoint-Properties"></a><a href=3D"=
#ConstraintTypes-cpGrooveJoint-Properties">Properties</a></h3>
<ul>
	<li><code>cpVect cpGrooveJointGetGrooveA(const cpConstraint *constraint=
)</code></li>
	<li><code>void cpGrooveJointSetGrooveA(cpConstraint *constraint, cpVect=
 value)</code></li>
	<li><code>cpVect cpGrooveJointGetGrooveB(const cpConstraint *constraint=
)</code></li>
	<li><code>void cpGrooveJointSetGrooveB(cpConstraint *constraint, cpVect=
 value)</code></li>
	<li><code>cpVect cpGrooveJointGetAnchr2(const cpConstraint *constraint)=
</code></li>
	<li><code>void cpGrooveJointSetAnchr2(cpConstraint *constraint, cpVect =
value)</code></li>
</ul>
<h2><a name=3D"ConstraintTypes-cpDampedSpring"></a><a href=3D"#Constrain=
tTypes-cpDampedSpring">Damped Spring:</a></h2>

<pre><code>cpDampedSpring *cpDampedSpringAlloc(void)

cpDampedSpring *cpDampedSpringInit(
	cpDampedSpring *joint, cpBody *a, cpBody *b, cpVect anchr1, cpVect anch=
r2,
	cpFloat restLength, cpFloat stiffness, cpFloat damping
)

cpConstraint *cpDampedSpringNew(
	cpBody *a, cpBody *b, cpVect anchr1, cpVect anchr2,
	cpFloat restLength, cpFloat stiffness, cpFloat damping
)</code></pre>
<p class=3D"expl">Defined much like a slide joint. <code>restLength</cod=
e> is the distance the spring wants to be, <code>stiffness</code> is the=
 spring constant (<a href=3D"http://en.wikipedia.org/wiki/Young&#39;s_mo=
dulus">Young&#8217;s modulus</a>), and <code>damping</code> is how soft =
to make the damping of the spring.</p>
<h3><a name=3D"ConstraintTypes-cpDampedSpring-Properties"></a><a href=3D=
"#ConstraintTypes-cpDampedSpring-Properties">Properties</a></h3>
<ul>
	<li><code>cpVect cpDampedSpringGetAnchr1(const cpConstraint *constraint=
)</code></li>
	<li><code>void cpDampedSpringSetAnchr1(cpConstraint *constraint, cpVect=
 value)</code></li>
	<li><code>cpVect cpDampedSpringGetAnchr2(const cpConstraint *constraint=
)</code></li>
	<li><code>void cpDampedSpringSetAnchr2(cpConstraint *constraint, cpVect=
 value)</code></li>
	<li><code>cpFloat cpDampedSpringGetRestLength(const cpConstraint *const=
raint)</code></li>
	<li><code>void cpDampedSpringSetRestLength(cpConstraint *constraint, cp=
Float value)</code></li>
	<li><code>cpFloat cpDampedSpringGetStiffness(const cpConstraint *constr=
aint)</code></li>
	<li><code>void cpDampedSpringSetStiffness(cpConstraint *constraint, cpF=
loat value)</code></li>
	<li><code>cpFloat cpDampedSpringGetDamping(const cpConstraint *constrai=
nt)</code></li>
	<li><code>void cpDampedSpringSetDamping(cpConstraint *constraint, cpFlo=
at value)</code></li>
</ul>
<h2><a name=3D"ConstraintTypes-cpDampedRotarySpring"></a><a href=3D"#Con=
straintTypes-cpDampedRotarySpring">Damped Rotary Spring:</a></h2>

<pre><code>cpDampedRotarySpring *cpDampedRotarySpringAlloc(void)

cpDampedRotarySpring *cpDampedRotarySpringInit(
	cpDampedRotarySpring *joint, cpBody *a, cpBody *b,
	cpFloat restAngle, cpFloat stiffness, cpFloat damping
)

cpConstraint *cpDampedRotarySpringNew(cpBody *a, cpBody *b, cpFloat rest=
Angle, cpFloat stiffness, cpFloat damping)</code></pre>
<p class=3D"expl">Like a damped spring, but works in an angular fashion.=
 <code>restAngle</code> is the relative angle in radians that the bodies=
 want to have, <code>stiffness</code> and <code>damping</code> work basi=
cally the same as on a damped spring.</p>
<h3><a name=3D"ConstraintTypes-cpDampedRotarySpring-Properties"></a><a h=
ref=3D"#ConstraintTypes-cpDampedRotarySpring-Properties">Properties</a><=
/h3>
<ul>
	<li><code>cpFloat cpDampedRotarySpringGetRestAngle(const cpConstraint *=
constraint)</code></li>
	<li><code>void cpDampedRotarySpringSetRestAngle(cpConstraint *constrain=
t, cpFloat value)</code></li>
	<li><code>cpFloat cpDampedRotarySpringGetStiffness(const cpConstraint *=
constraint)</code></li>
	<li><code>void cpDampedRotarySpringSetStiffness(cpConstraint *constrain=
t, cpFloat value)</code></li>
	<li><code>cpFloat cpDampedRotarySpringGetDamping(const cpConstraint *co=
nstraint)</code></li>
	<li><code>void cpDampedRotarySpringSetDamping(cpConstraint *constraint,=
 cpFloat value)</code></li>
</ul>
<h2><a name=3D"ConstraintTypes-cpRotaryLimitJoint"></a><a href=3D"#Const=
raintTypes-cpRotaryLimitJoint">Rotary Limit Joint:</a></h2>

<pre><code>cpRotaryLimitJoint *cpRotaryLimitJointAlloc(void)
cpRotaryLimitJoint *cpRotaryLimitJointInit(cpRotaryLimitJoint *joint, cp=
Body *a, cpBody *b, cpFloat min, cpFloat max)
cpConstraint *cpRotaryLimitJointNew(cpBody *a, cpBody *b, cpFloat min, c=
pFloat max)</code></pre>
<p class=3D"expl">Constrains the relative rotations of two bodies. <code=
>min</code> and <code>max</code> are the angular limits in radians. It i=
s implemented so that it&#8217;s possible to for the range to be greater=
 than a full revolution.</p>
<h3><a name=3D"ConstraintTypes-cpRotaryLimitJoint-Properties"></a><a hre=
f=3D"#ConstraintTypes-cpRotaryLimitJoint-Properties">Properties</a></h3>=

<ul>
	<li><code>cpFloat cpRotaryLimitJointGetMin(const cpConstraint *constrai=
nt)</code></li>
	<li><code>void cpRotaryLimitJointSetMin(cpConstraint *constraint, cpFlo=
at value)</code></li>
	<li><code>cpFloat cpRotaryLimitJointGetMax(const cpConstraint *constrai=
nt)</code></li>
	<li><code>void cpRotaryLimitJointSetMax(cpConstraint *constraint, cpFlo=
at value)</code></li>
</ul>
<h2><a name=3D"ConstraintTypes-cpRatchetJoint"></a><a href=3D"#Constrain=
tTypes-cpRatchetJoint">Ratchet Joint:</a></h2>

<pre><code>cpRatchetJoint *cpRatchetJointAlloc(void);
cpRatchetJoint *cpRatchetJointInit(cpRatchetJoint *joint, cpBody *a, cpB=
ody *b, cpFloat phase, cpFloat ratchet);
cpConstraint *cpRatchetJointNew(cpBody *a, cpBody *b, cpFloat phase, cpF=
loat ratchet);</code></pre>
<p class=3D"expl">Works like a socket wrench. <code>ratchet</code> is th=
e distance between &#8220;clicks&#8221;, <code>phase</code> is the initi=
al offset to use when deciding where the ratchet angles are.</p>
<h3><a name=3D"ConstraintTypes-cpRatchetJoint-Properties"></a><a href=3D=
"#ConstraintTypes-cpRatchetJoint-Properties">Properties</a></h3>
<ul>
	<li><code>cpFloat cpRatchetJointGetAngle(const cpConstraint *constraint=
)</code></li>
	<li><code>void cpRatchetJointSetAngle(cpConstraint *constraint, cpFloat=
 value)</code></li>
	<li><code>cpFloat cpRatchetJointGetPhase(const cpConstraint *constraint=
)</code></li>
	<li><code>void cpRatchetJointSetPhase(cpConstraint *constraint, cpFloat=
 value)</code></li>
	<li><code>cpFloat cpRatchetJointGetRatchet(const cpConstraint *constrai=
nt)</code></li>
	<li><code>void cpRatchetJointSetRatchet(cpConstraint *constraint, cpFlo=
at value)</code></li>
</ul>
<h2><a name=3D"ConstraintTypes-cpGearJoint"></a><a href=3D"#ConstraintTy=
pes-cpGearJoint">Gear Joint:</a></h2>

<pre><code>cpGearJoint *cpGearJointAlloc(void);
cpGearJoint *cpGearJointInit(cpGearJoint *joint, cpBody *a, cpBody *b, c=
pFloat phase, cpFloat ratio);
cpConstraint *cpGearJointNew(cpBody *a, cpBody *b, cpFloat phase, cpFloa=
t ratio);</code></pre>
<p class=3D"expl">Keeps the angular velocity ratio of a pair of bodies c=
onstant. <code>ratio</code> is always measured in absolute terms. It is =
currently not possible to set the ratio in relation to a third body&#821=
7;s angular velocity. <code>phase</code> is the initial angular offset o=
f the two bodies.</p>
<h3><a name=3D"ConstraintTypes-cpGearJoint-Properties"></a><a href=3D"#C=
onstraintTypes-cpGearJoint-Properties">Properties</a></h3>
<ul>
	<li><code>cpFloat cpGearJointGetPhase(const cpConstraint *constraint)</=
code></li>
	<li><code>void cpGearJointSetPhase(cpConstraint *constraint, cpFloat va=
lue)</code></li>
	<li><code>cpFloat cpGearJointGetRatio(const cpConstraint *constraint)</=
code></li>
	<li><code>void cpGearJointSetRatio(cpConstraint *constraint, cpFloat va=
lue)</code></li>
</ul>
<h2><a name=3D"ConstraintTypes-cpSimpleMotor"></a><a href=3D"#Constraint=
Types-cpSimpleMotor">Simple Motor:</a></h2>

<pre><code>cpSimpleMotor *cpSimpleMotorAlloc(void);
cpSimpleMotor *cpSimpleMotorInit(cpSimpleMotor *joint, cpBody *a, cpBody=
 *b, cpFloat rate);
cpConstraint *cpSimpleMotorNew(cpBody *a, cpBody *b, cpFloat rate);</cod=
e></pre>
<p class=3D"expl">Keeps the relative angular velocity of a pair of bodie=
s constant. <code>rate</code> is the desired relative angular velocity. =
You will usually want to set an force (torque) maximum for motors as oth=
erwise they will be able to apply a nearly infinite torque to keep the b=
odies moving.</p>
<h3><a name=3D"ConstraintTypes-cpSimpleMotor-Properties"></a><a href=3D"=
#ConstraintTypes-cpSimpleMotor-Properties">Properties</a></h3>
<ul>
	<li><code>cpFloat cpSimpleMotorGetRate(const cpConstraint *constraint)<=
/code></li>
	<li><code>void cpSimpleMotorSetRate(cpConstraint *constraint, cpFloat v=
alue)</code></li>
</ul>
<h2><a name=3D"ConstraintTypes-Notes"></a><a href=3D"#ConstraintTypes-No=
tes">Notes:</a></h2>
<ul>
	<li>You can add multiple joints between two bodies, but make sure that =
they don&#8217;t fight. Doing so can cause the bodies jitter or spin vio=
lently.</li>
</ul>
<h1><a name=3D"CollisionDetection"></a><a href=3D"#CollisionDetection">O=
verview of Collision Detection in Chipmunk:</a></h1>
<p>In order to make collision detection in Chipmunk as fast as possible,=
 the process is broken down into several stages. While I&#8217;ve tried =
to keep it conceptually simple, the implementation can be a bit daunting=
. Fortunately as a user of the library, you don&#8217;t need to understa=
nd everything about how it works. Though if you are trying to squeeze ev=
ery ounce of performance out of Chipmunk, understanding this section can=
 be helpful.</p>
<h2><a name=3D"CollisionDetection-SpatialIndexing"></a><a href=3D"#Colli=
sionDetection-SpatialIndexing">Spatial Indexing:</a></h2>
<p>A for loop that checks every object against every other object in the=
 scene would be <em>very</em> slow. So the first stage of the collision =
detection (or broadphase as it is commonly called), is to use a high lev=
el spatial algorithm to figure out which objects should be even be check=
ed for collisions. Currently Chipmunk supports two spatial indexes, an a=
xis-aligned bounding box tree and a spatial hash. These spatial indexes =
are able to quickly identify which shapes are near each other and should=
 be checked for a collision.</p>
<h2><a name=3D"CollisionDetection-Filtering"></a><a href=3D"#CollisionDe=
tection-Filtering">Collision Filtering:</a></h2>
<p>After the spatial index figures out which pairs of shapes are likely =
to be near each other, it passes them back to the space to perform some =
additional filtering on the pairs. Before doing anything else, Chipmunk =
performs a few quick tests to check if shapes should collide.</p>
<ul>
	<li><strong>Bounding Box Test:</strong> The shapes are not colliding if=
 their bounding boxes are not overlapping. Objects like diagonal line se=
gments can trigger a lot of false positives here, but it&#8217;s unlikel=
y to be something you should worry about.</li>
	<li><strong>Layer Test:</strong> The shapes are not colliding if they d=
on&#8217;t occupy any of the same layers. (the bitwise <span class=3D"ca=
ps">AND</span> of their layer masks is 0)</li>
	<li><strong>Group Test:</strong> Shapes shouldn&#8217;t collide with ot=
her shapes in the same non-zero group.</li>
</ul>
<h2><a name=3D"CollisionDetection-PrimitiveTest"></a><a href=3D"#Collisi=
onDetection-PrimitiveTest">Primitive Shape to Shape Collision Detection:=
</a></h2>
<p>The most expensive test is to actually check for overlap based on the=
ir geometry. Circle to circle and circle to line collisions are pretty q=
uick. Poly to poly collisions get more expensive as the number of vertex=
es increases. Simpler shapes make for faster collisions (and more import=
antly fewer collision points for the solver to run). Chipmunk uses a sma=
ll dispatch table to figure out which function to use to check if the sh=
apes overlap.</p>
<h2><a name=3D"CollisionDetection-HandlerFiltering"></a><a href=3D"#Coll=
isionDetection-HandlerFiltering">Collision Handler Filtering:</a></h2>
<p>After checking if two shapes overlap Chipmunk will look to see if you=
 have defined a collision handler for the collision types of the shapes.=
 This is vital to process collisions events for the gameplay, but also g=
ives you a very flexible way to filter out collisions. The return value =
of the <code>begin()</code> and <code>preSolve()</code> callbacks determ=
ines whether or not the colliding pair of shapes is discarded or not. Re=
turning true will keep the pair, false will discard it. Rejecting a coll=
ision from a <code>begin()</code> callback is permanent, rejecting it fr=
om the <code>preSolve()</code> only applies to the step it occured in. I=
f you don&#8217;t define a handler for the given collision_types, Chipmu=
nk will call the space&#8217;s default handler, which by default is defi=
ned to simply accept all collisions.</p>
<p>While using callbacks to filter collisions is the most flexible way, =
keep in mind that by the time your callback is called all of the most ex=
pensive collision detection has already been done. For simulations with =
a lot of colliding objects each frame, the time spent finding collisions=
 is small compared to the time spent solving the physics for them so it =
may not be a big deal. Still, use layers or groups first if you can.</p>=

<h1><a name=3D"CollisionCallbacks"></a><a href=3D"#CollisionCallbacks">C=
ollision Callbacks:</a></h1>
<p>A physics library without any events or feedback would not be very us=
eful for games. How would you know when the player bumped into an enemy =
so that you could take some health points away? How would you know how h=
ard the car hit something so you don&#8217;t play a loud crash noise whe=
n a pebble hits it? What if you need to decide if a collision should be =
ignored based on specific conditions, like implementing one way platform=
s? Chipmunk has a number of powerful callback systems that you can plug =
into to accomplish all of that.</p>
<h2><a name=3D"CollisionCallbacks-Handlers"></a><a href=3D"#CollisionCal=
lbacks-Handlers">Collision Handlers:</a></h2>
<p>A collision handler is a set of 4 function callbacks for the differen=
t collision events that Chipmunk recognizes. The event types are:</p>
<ul>
	<li><code>begin()</code>: Two shapes just started touching for the firs=
t time this step. Return true from the callback to process the collision=
 normally or false to cause Chipmunk to ignore the collision entirely. I=
f you return false, the <code>preSolve()</code> and <code>postSolve()</c=
ode> callbacks will never be run, but you will still recieve a separate =
event when the shapes stop overlapping.</li>
	<li><code>preSolve()</code>: Two shapes are touching during this step. =
Return false from the callback to make Chipmunk ignore the collision thi=
s step or true to process it normally. Additionally, you may override co=
llision values such as cpArbiter.e and cpArbiter.u to provide custom fri=
ction or elasticity values. See <a href=3D"#cpArbiter">cpArbiter</a> for=
 more info.</li>
	<li><code>postSolve()</code>: Two shapes are touching and their collisi=
on response has been processed. You can retrieve the collision force at =
this time if you want to use it to calculate sound volumes or damage amo=
unts. See <a href=3D"#cpArbiter">cpArbiter</a> for more info.</li>
	<li><code>separate()</code>: Two shapes have just stopped touching for =
the first time this step.</li>
</ul>
<p>Collision callbacks are closely associated with <a href=3D"#cpArbiter=
">cpArbiter</a> structs. You should familiarize yourself with those as w=
ell.</p>
<p><strong>Note:</strong> Shapes tagged as sensors (<code>cpShape.sensor=
 =3D=3D true</code>) never generate collisions that get processed so col=
lisions between sensors shapes and other shapes will never call the <cod=
e>postSolve()</code> callback. They still generate <code>begin()</code>,=
 and <code>separate()</code> callbacks, and the <code>preSolve()</code> =
callback is also called every frame even though there is no real collisi=
on.</p>
<p><strong>Note #2:</strong> <code>preSolve()</code> callbacks are calle=
d before the sleeping algorithm runs. If an object falls asleep, it&#821=
7;s <code>postSolve()</code> callback won&#8217;t be called until it&#82=
17;s reawoken.</p>
<h2><a name=3D"CollisionCallbacks-HandlerAPI"></a><a href=3D"#CollisionC=
allbacks-HandlerAPI">Collision Handler <span class=3D"caps">API</span>:<=
/a></h2>

<pre><code>typedef int (*cpCollisionBeginFunc)(cpArbiter *arb, struct cp=
Space *space, void *data)
typedef int (*cpCollisionPreSolveFunc)(cpArbiter *arb, cpSpace *space, v=
oid *data)
typedef void (*cpCollisionPostSolveFunc)(cpArbiter *arb, cpSpace *space,=
 void *data)
typedef void (*cpCollisionSeparateFunc)(cpArbiter *arb, cpSpace *space, =
void *data)</code></pre>
<p class=3D"expl">Collision handler function types. While all of them ta=
ke an arbiter, space, and a user data pointer, only the <code>begin()</c=
ode> and <code>preSolve()</code> callbacks return a value. See above for=
 more information.</p>
<pre><code>void cpSpaceAddCollisionHandler(
	cpSpace *space,
	cpCollisionType a, cpCollisionType b,
	cpCollisionBeginFunc begin,
	cpCollisionPreSolveFunc preSolve,
	cpCollisionPostSolveFunc postSolve,
	cpCollisionSeparateFunc separate,
	void *data
)</code></pre>
<p class=3D"expl">Add a collision handler for given collision type pair.=
 Whenever a shapes with collision type (<code>cpShape.collision_type</co=
de>) <code>a</code> and collision type <code>b</code> collide, these cal=
lbacks will be used to process the collision. <code>data</code> is a use=
r definable context pointer that is passed to each of the callbacks. <sp=
an class=3D"caps">NULL</span> can be provided for callbacks you do not w=
ish to implement, however Chipmunk will call it&#8217;s own default vers=
ions for these and not the default ones you&#8217;ve set up for the spac=
e. If you need to fall back on the space&#8217;s default callbacks, you&=
#8217;ll have to provide them individually to each handler definition.</=
p>
<pre><code>void cpSpaceRemoveCollisionHandler(cpSpace *space, cpCollisio=
nType a, cpCollisionType b)</code></pre>
<p class=3D"expl">Remove a collision handler for a given collision type =
pair.</p>
<pre><code>void cpSpaceSetDefaultCollisionHandler(
	cpSpace *space,
	cpCollisionBeginFunc begin,
	cpCollisionPreSolveFunc preSolve,
	cpCollisionPostSolveFunc postSolve,
	cpCollisionSeparateFunc separate,
	void *data
)</code></pre>
<p class=3D"expl">Register a default collision handler to be used when n=
o specific collision handler is found. The space is given a default hand=
ler when created that returns true for all collisions in <code>begin()</=
code> and <code>preSolve()</code> and does nothing in the <code>postSolv=
e()</code> and <code>separate()</code> callbacks.</p>
<h2><a name=3D"CollisionCallbacks-PostStep"></a><a href=3D"#CollisionCal=
lbacks-PostStep">Post-Step Callbacks:</a></h2>
<p>Post-step callbacks are the one place where you can break the rules a=
bout adding or removing objects from within a callback. In fact, their p=
rimary function is to help you safely remove objects from the space that=
 you wanted to disable or destroy in a collision or query callback.</p>
<p>Post step callbacks are registered as a function and a pointer that i=
s used as a key. You can only register one <code>postStep()</code> callb=
ack per key. This prevents you from accidentally removing an object more=
 than once. For instance, say that you get a collision callback between =
a bullet and object A. You want to destroy both the bullet and object A,=
 so you register a <code>postStep()</code> callback to safely remove the=
m from your game. Then you get a second collision callback between the b=
ullet and object B. You register a <code>postStep()</code> callback to r=
emove object B, and a second <code>postStep()</code> callback to remove =
the bullet. Because you can only register one callback per key, the <cod=
e>postStep()</code> callback for the bullet will only be called once and=
 you can&#8217;t accidentally try to remove it twice.</p>
<pre><code>typedef void (*cpPostStepFunc)(cpSpace *space, void *obj, voi=
d *data)</code></pre>
<p class=3D"expl">Function type used for <code>postStep()</code> callbac=
ks. <code>space</code> is the space the callback was registered on, <cod=
e>obj</code> is the pointer value you supplied as the key, and <code>dat=
a</code> is a user definable pointer you can use to pass in as a context=
 value.</p>
<pre><code>void cpSpaceAddPostStepCallback(cpSpace *space, cpPostStepFun=
c func, void *obj, void *data)</code></pre>
<p class=3D"expl">Add <code>func</code> to be called before <code>cpSpac=
eStep()</code> returns. <code>obj</code> and <code>data</code> will be p=
assed to your function. Only the last callback registered for any unique=
 value of <code>obj</code> will be recorded. You can add <code>postStep(=
)</code> callbacks from outside of other callback functions, but there i=
sn&#8217;t a good reason to and they won&#8217;t be called until the nex=
t time <code>cpSpaceStep()</code> is finishing.</p>
<p><strong>Note:</strong> Post-step callbacks are not run in any particu=
lar order. If you need to sequence a number of events, you&#8217;ll need=
 to put them in a single callback.</p>
<h2><a name=3D"CollisionCallbacks-Examples"></a><a href=3D"#CollisionCal=
lbacks-Examples">Examples:</a></h2>
<p>See the <a href=3D"examples.html#CollisionCallbacks">callback example=
s</a> for more information.</p>
<h1><a name=3D"cpArbiter"></a><a href=3D"#cpArbiter">Chipmunk Collision =
Pairs: <code>cpArbiter</code></a></h1>
<p>Chipmunk&#8217;s <code>cpArbiter</code> struct encapsulates a pair of=
 colliding shapes and all of the data about their collision.</p>
<p>Why are they called arbiters? The short answer is that Box2D called t=
hem that way back in 2006 when I was looking at the source for it&#8217;=
s solver. An arbiter is like a judge, a person that has authority to set=
tle disputes between two people. It was a fun, fitting name and was shor=
ter to type than CollisionPair which I had been using. It was originally=
 meant to be a private internal structure only, but evolved to be useful=
 from callbacks.</p>
<h2><a name=3D"cpArbiter-Memory"></a><a href=3D"#cpArbiter-Memory">Memor=
y Management:</a></h2>
<p>You will never need to create or free an arbiter. More importantly, b=
ecause they are entirely managed by the space you should <strong>never</=
strong> store a reference to an arbiter as you don&#8217;t know when the=
y will be recycled. Use them within the callback where they are given to=
 you and then forget about them or copy out the information you need.</p=
>
<h2><a name=3D"cpArbiter-Properties"></a><a href=3D"#cpArbiter-Propertie=
s">Properties:</a></h2>

<pre><code>cpFloat cpArbiterGetElasticity(const cpArbiter *arb)
void cpArbiterSetElasticity(cpArbiter *arb, cpFloat value)</code></pre>
<p class=3D"expl">The calculated elasticity for this collision pair. Set=
ting the value in a <code>preSolve()</code> callback will override the v=
alue calculated by the space.</p>
<pre><code>cpFloat cpArbiterGetFriction(const cpArbiter *arb)
void cpArbiterSetFriction(cpArbiter *arb, cpFloat value)</code></pre>
<p class=3D"expl">The calculated friction for this collision pair. Setti=
ng the value in a <code>preSolve()</code> callback will override the val=
ue calculated by the space.</p>
<pre><code>cpVect cpArbiterGetSurfaceVelocity(const cpArbiter *arb)
void cpArbiterSetSurfaceVelocity(cpArbiter *arb, cpVect value)</code></p=
re>
<p class=3D"expl">The calculated surface velocity for this collision pai=
r. Setting the value in a <code>preSolve()</code> callback will override=
 the value calculated by the space.</p>
<pre><code>int cpArbiterGetCount(const cpArbiter *arb)
cpVect cpArbiterGetNormal(const cpArbiter *arb, int i)
cpVect cpArbiterGetPoint(const cpArbiter *arb, int i)
cpFloat cpArbiterGetDepth(const cpArbiter *arb, int i)</code></pre>
<p class=3D"expl">Get the number of contacts tracked by this arbiter or =
the specific collision point, collision normal or penetration depth of a=
 collision point.</p>
<pre><code>cpBool cpArbiterIsFirstContact(const cpArbiter *arb)</code></=
pre>
<p class=3D"expl">Returns true if this is the first step the two shapes =
started touching. Can be used</p>
<pre><code>void cpArbiterGetShapes(const cpArbiter *arb, cpShape **a, cp=
Shape **b)
void cpArbiterGetBodies(const cpArbiter *arb, cpBody **a, cpBody **b)</c=
ode></pre>
<p class=3D"expl">Get the shapes or bodies in the order that they were d=
efined in the collision handler associated with this arbiter. If you def=
ined the handler as <code>cpSpaceAddCollisionHandler(space, 1, 2, ...)</=
code>, you you will find that <code>a-&gt;collision_type =3D=3D 1</code>=
 and <code>b-&gt;collision_type =3D=3D 2</code>.</p>
<div><a class=3D"HideShow" href=3D"javascript:;" onmousedown=3D"toggleEx=
ample('Pop Open CollisionCallback Example', 'examples/CollisionCallback.=
html');">Hide/Show CollisionCallback Example</a><div id=3D"Pop Open Coll=
isionCallback Example" style=3D"display:none"></div></div>
<h2><a name=3D"cpArbiter-HelperFunctions"></a><a href=3D"#cpArbiter-Help=
erFunctions">Contact Point Sets:</a></h2>
<p>Contact point sets make getting contact information simpler.</p>
<pre><code>cpContactPointSet cpArbiterGetContactPointSet(const cpArbiter=
 *arb)</code></pre>
<p class=3D"expl">Get a contact point set struct from an arbiter.</p>
<p>You might do something like the following to get and process a contac=
t point set:</p>
<pre><code>cpContactPointSet set =3D cpArbiterGetContactPointSet(arbiter=
);
for(int i=3D0; i&lt;set.count; i++){
	// get and work with the collision point normal and penetration distanc=
e:
	set.points[i].point
	set.points[i].normal
	set.points[i].dist
}</code></pre>
<h2><a name=3D"cpArbiter-HelperFunctions"></a><a href=3D"#cpArbiter-Help=
erFunctions">Helper Functions:</a></h2>

<pre><code>void cpArbiterGetShapes(cpArbiter *arb, cpShape **a, cpShape =
**b)
void cpArbiterGetBodies(const cpArbiter *arb, cpBody **a, cpBody **b)</c=
ode></pre>
<p class=3D"expl">Get the shapes (or their bodies) in the order that the=
y were defined in the collision handler associated with this arbiter. If=
 you defined the handler as <code>cpSpaceAddCollisionHandler(space, 1, 2=
, ...)</code>, you you will find that <code>a-&gt;collision_type =3D=3D =
1</code> and <code>b-&gt;collision_type =3D=3D 2</code>. The convenience=
 macro defines and initializes the two shape variables for you. The defa=
ult collision handler doesn&#8217;t use collision types so the order is =
undefined.</p>
<pre><code>#define CP_ARBITER_GET_SHAPES(arb, a, b) cpShape *a, *b; cpAr=
biterGetShapes(arb, &amp;a, &amp;b)
#define CP_ARBITER_GET_BODIES(arb, a, b) cpBody *a, *b; cpArbiterGetBodi=
es(arb, &amp;a, &amp;b);</code></pre>
<p class=3D"expl">Shortcut macros for defining variables for and retriev=
ing the shapes/bodies for an arbiter.</p>
<pre><code>cpVect cpArbiterTotalImpulseWithFriction(cpArbiter *arb);
cpVect cpArbiterTotalImpulse(cpArbiter *arb);</code></pre>
<p class=3D"expl">Returns the impulse that was applied this step to reso=
lve the collision. These functions should only be called from a <code>po=
stStep()</code> or <code>cpBodyEachArbiter()</code> callback, otherwise =
the result is undefined. If in doubt which function to use, use <code>cp=
ArbiterTotalImpulseWithFriction()</code>.</p>
<pre><code>cpFloat cpArbiterTotalKE(const cpArbiter *arb);</code></pre>
<p class=3D"expl">Calculate the amount of energy lost in a collision inc=
luding static, but not dynamic friction. This function should only be ca=
lled from a <code>postSolve()</code>, <code>postStep()</code> or <code>c=
pBodyEachArbiter()</code> callback.</p>
<h1><a name=3D"Queries"></a><a href=3D"#Queries">Queries:</a></h1>
<p>Chipmunk spaces support four kinds of spatial queries, point, segment=
, shape and fast bounding box queries. Any type can be performed efficie=
ntly against an entire space, and point and segment queries can be perfo=
rmed against individual shapes. All types of queries take a collision gr=
oup and layer that are used to filter matches out using the same rules u=
sed for filtering collisions between shapes. See <a href=3D"#cpShape">cp=
Shape</a> for more information. If you don&#8217;t want to filter out an=
y matches, use <code>CP_ALL_LAYERS</code> for the layers and <code>CP_NO=
_GROUP</code> as the group.</p>
<h2><a name=3D"Queries-PointQueries"></a><a href=3D"#Queries-PointQuerie=
s">Point Queries:</a></h2>
<p>Point queries are useful for things like mouse picking and simple sen=
sors.</p>
<pre><code>cpBool cpShapePointQuery(cpShape *shape, cpVect p)</code></pr=
e>
<p class=3D"expl">Check if the given point lies within the shape.</p>
<pre><code>typedef void (*cpSpacePointQueryFunc)(cpShape *shape, void *d=
ata);

void cpSpacePointQuery(
	cpSpace *space, cpVect point,
	cpLayers layers, cpGroup group,
	cpSpacePointQueryFunc func, void *data
)</code></pre>
<p class=3D"expl">Query <code>space</code> at <code>point</code> filteri=
ng out matches with the given <code>layers</code> and <code>group</code>=
. <code>func</code> is called for each shape found along with the <code>=
data</code> argument passed to <code>cpSpacePointQuery()</code>. Sensor =
shapes are included.</p>
<pre><code>cpShape *cpSpacePointQueryFirst(cpSpace *space, cpVect point,=
 cpLayers layers, cpGroup group)</code></pre>
<p class=3D"expl">Query <code>space</code> at <code>point</code> and ret=
urn the first shape found matching the given <code>layers</code> and <co=
de>group</code>. Returns <code>NULL</code> if no shape was found.  Senso=
r shapes are ignored.</p>
<h2><a name=3D"Queries-SegmentQueries"></a><a href=3D"#Queries-SegmentQu=
eries">Segment Queries:</a></h2>
<p>Segment queries are like ray casting, but because not all spatial ind=
exes allow processing infinitely long ray queries it is limited to segme=
nts. In practice this is still very fast and you don&#8217;t need to wor=
ry too much about the performance as long as you aren&#8217;t using extr=
emely long segments for your queries.</p>
<pre><code>typedef struct cpSegmentQueryInfo{
	struct cpShape *shape; // shape that was hit, NULL if no collision
	cpFloat t; // Distance along query segment, will always be in the range=
 "1":0,.
	cpVect n; // normal of hit surface
} cpSegmentQueryInfo;</code></pre>
<p class=3D"expl">Segment queries return more information than just a si=
mple yes or no, they also return where a shape was hit and it&#8217;s su=
rface normal at the hit point. <code>t</code> is the percentage between =
the query start and end points. If you need the hit point in world space=
 or the absolute distance from start, see the segment query helper funct=
ions farther down.</p>
<pre><code>cpBool cpShapeSegmentQuery(cpShape *shape, cpVect a, cpVect b=
, cpSegmentQueryInfo *info)</code></pre>
<p class=3D"expl">Perform a segment query from <code>a</code> to <code>b=
</code> against a single shape <code>shape</code>. <code>info</code> mus=
t be a valid pointer to a <code>cpSegmentQueryInfo</code> structure whic=
h will be initialized with the raycast info.</p>
<pre><code>typedef void (*cpSpaceSegmentQueryFunc)(cpShape *shape, cpFlo=
at t, cpVect n, void *data)

void cpSpaceSegmentQuery(
	cpSpace *space, cpVect start, cpVect end,
	cpLayers layers, cpGroup group,
	cpSpaceSegmentQueryFunc func, void *data
)</code></pre>
<p class=3D"expl">Query <code>space</code> along the line segment from <=
code>start</code> to <code>end</code> filtering out matches with the giv=
en <code>layers</code> and <code>group</code>. <code>func</code> is call=
ed with the normalized distance along the line and surface normal for ea=
ch shape found along with the <code>data</code> argument passed to <code=
>cpSpacePointQuery()</code>.  Sensor shapes are included.</p>
<pre><code>cpShape *cpSpaceSegmentQueryFirst(
	cpSpace *space, cpVect start, cpVect end,
	cpLayers layers, cpGroup group,
	cpSegmentQueryInfo *info
)</code></pre>
<p class=3D"expl">Query <code>space</code> along the line segment from <=
code>start</code> to <code>end</code> filtering out matches with the giv=
en <code>layers</code> and <code>group</code>. Only the first shape enco=
untered is returned and the search is short circuited. Returns <code>NUL=
L</code> if no shape was found. The info struct pointed to by <code>info=
</code> will be initialized with the raycast info unless <code>info</cod=
e> is <span class=3D"caps">NULL</span>. Sensor shapes are ignored.</p>
<h3><a name=3D"Queries-SegmentQueries-HelperFunctions"></a><a href=3D"#Q=
ueries-SegmentQueries-HelperFunctions">Segment Query Helper Functions:</=
a></h3>

<pre><code>cpVect cpSegmentQueryHitPoint(cpVect start, cpVect end, cpSeg=
mentQueryInfo info)</code></pre>
<p class=3D"expl">Return the hit point in world coordinates where the se=
gment first intersected with the shape.</p>
<pre><code>cpFloat cpSegmentQueryHitDist(cpVect start, cpVect end, cpSeg=
mentQueryInfo info)</code></pre>
<p class=3D"expl">Return the absolute distance where the segment first h=
it the shape.</p>
<h2><a name=3D"Queries-AABBQueries"></a><a href=3D"#Queries-AABBQueries"=
><span class=3D"caps">AABB</span> Queries:</a></h2>
<p><span class=3D"caps">AABB</span> queries give you a fast way to check=
 roughly which shapes are in an area.</p>
<pre><code>typedef void (*cpSpaceBBQueryFunc)(cpShape *shape, void *data=
)

void cpSpaceBBQuery(
	cpSpace *space, cpBB bb,
	cpLayers layers, cpGroup group,
	cpSpaceBBQueryFunc func, void *data
)</code></pre>
<p class=3D"expl">Query <code>space</code> to find all shapes near <code=
>bb</code> filtering out matches with the given <code>layers</code> and =
<code>group</code>. <code>func</code> is called for each shape whose bou=
nding box overlaps <code>bb</code> along with the <code>data</code> argu=
ment passed to <code>cpSpaceBBQuery()</code>. Sensor shapes are included=
.</p>
<h2><a name=3D"Queries-ShapeQueries"></a><a href=3D"#Queries-ShapeQuerie=
s">Shape Queries:</a></h2>
<p>Shape queries allow you to check if shapes in a space are overlapping=
 a specific area. You can use this to check if an object already exists =
at a location you want to add another shape, or to use as sensor queries=
 for AI.</p>
<p>You can either create a body/shape pair before querying, or you can c=
reate a shape passing <code>NULL</code> for the body and position the sh=
ape using <code>cpShapeUpdate()</code> to set the position and rotation =
of the shape.</p>
<pre><code>typedef void (*cpSpaceShapeQueryFunc)(cpShape *shape, cpConta=
ctPointSet *points, void *data);

cpBool cpSpaceShapeQuery(cpSpace *space, cpShape *shape, cpSpaceShapeQue=
ryFunc func, void *data);</code></pre>
<p class=3D"expl">Query <code>space</code> to find all shapes overlappin=
g <code>shape</code>. Matches are filtered using the layers and group of=
 <code>shape</code>. <code>func</code> is called for each overlapping sh=
ape along with a pointer to a temporary cpContactPointSet and the <code>=
data</code> argument passed to <code>cpSpaceBBQuery()</code>. Sensor sha=
pes are included.</p>
<h2><a name=3D"Queries-Examples"></a><a href=3D"#Queries-Examples">Examp=
les:</a></h2>
<p>See the <a href=3D"examples.html#Query">query examples</a> for more i=
nformation.</p>
		</body>
	</html>

------------Y47EGPtdbWNKttFrOftBHR
Content-Disposition: inline; filename=stylesheet.css
Content-Type: text/css; charset=utf-8; name=stylesheet.css
Content-Location: http://chipmunk-physics.net/release/ChipmunkLatest-Docs/stylesheet.css
Content-Transfer-Encoding: 8bit

h1, h2 {
	padding: 0.25em;
	border-radius: 0.25em;
}

h1 {
	background-color: #89b4cb;
}

h2 {
	background-color: lightGrey;
}

p {
	margin-left: 1em;
}

p.expl {
	margin-left: 2em;
}

code {
	color: #191970
}

.HideShow {
	background-color: lightGrey;
	padding: 0.5em;
	border-radius: 1em;
	border: 2px grey solid;
}

.PopOpen {
	border-radius: 1em;
	border: 1px grey solid;
}

pre {
	border-radius: 0.75em;
	background-color: #F0F0F0;
	padding: 0.5em;
	margin-left: 1em;
}

/*ul {
	border-radius: 0.75em;
	background-color: #F0F0F0;
	margin-left: 1em;
}*/

table {
	border: 2px solid black;
	border-collapse: collapse;
	margin-left: 1em;
}

table td, th {
	border: 1px black solid;
	padding: 0.5em;
}

h1 a:link, h2 a:link, h3 a:link, h1 a:visited, h2 a:visited, h3 a:visited {
	text-decoration:none;
	color:black;
	background-color:transparent
}

h1 a:hover, h2 a:hover, h3 a:hover, h1 a:active, h2 a:active, h3 a:active {
	text-decoration:underline;
	color:black;
	background-color:transparent
}

------------Y47EGPtdbWNKttFrOftBHR
Content-Disposition: inline; filename=logo1_med.png
Content-Type: image/png; name=logo1_med.png
Content-Location: http://chipmunk-physics.net/release/ChipmunkLatest-Docs/images/logo1_med.png
Content-Transfer-Encoding: Base64

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
lkXC8AAAAABJRU5ErkJggg==

------------Y47EGPtdbWNKttFrOftBHR
Content-Disposition: inline; filename=hms_logo.png
Content-Type: image/png; name=hms_logo.png
Content-Location: http://chipmunk-physics.net/release/ChipmunkLatest-Docs/images/hms_logo.png
Content-Transfer-Encoding: Base64

iVBORw0KGgoAAAANSUhEUgAAAIMAAACDCAYAAACunahmAAAACXBIWXMAAAsTAAAL
EwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj33
3vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEs
DIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIe
EeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH
/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAn
f+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJ
V2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4
mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHg
g/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl
7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/A
V/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5
WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQ
WHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAA
RKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv
1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4
IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGy
UT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPE
bDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhM
WE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPE
NyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD
5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2h
tlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0
dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHK
CpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2ep
O6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN
2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIp
G6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3n
U9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36
p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYP
jGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLn
m+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cR
p7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0H
DYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dn
F2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofc
n8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh
7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJ
gUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5p
DoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85
ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7
F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/R
NtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9
MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo
1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5
sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWF
fevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTP
ZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJ
zs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ
+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3v
dy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtb
Ylu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ7
52PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7
nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9
zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9D
BY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfy
l5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT
0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADq
YAAAOpgAABdvkl/FRgAAI0NJREFUeNrtXQl0VFW2pVfb/Vv7YysoNtJfv60toP3V
bhXtxrEBZVAUlUFQBGSQUQwghEASMlYqI4GEQCZmEAKEhBCGIDMyhxkZlZmAOKGo
DJ6/9633wkuRSqqSepWqwF3rrEoqlVfv3bPvuWe+NUSkRjWnW0H3gBqBWoO6gfxA
waAoUAIoUXuN0t730z7XWvu/e7TrVOu5qm4PVAf0HKgPaDxoFWg/6Dup3PhOu84q
7bp9tO+pcwMM3kO1tNUbBloLOuUMZ69c+VUuXb4iv1y6LD+TLtpe+Tvf59+dHKe0
7w3T7qPWDTB4lv4K6guaBTpTKrN//VV++PminPjmvOw+fk4+O3BSFu34UuZsOiDT
1u2VjFW7ZPynOyRp6TZJXFIooxcXqlf+zvf5d36On+f/8f95HV6P1+X1HYwz2n31
1e7zBhhMEv8dQfmg8/YcuHjpipz+9kfZ+mWR5G//Qiau3i1jwFxL7iYJn79BQrPX
SwiIr2H4ne9F5GxUFEnKtb3q7/HvYXb/x/d4PV534qrd6nv4ffxefn8p47x2vx19
ZTvx9huk8jYOdOKaTfzCL2q1Lig8LBOW7xBr3iYwzcbAUfM+k/CcDRK1YJNbyQIi
cHSAkfi9/H7eB++H91XKOKE9R6MbYHCdmoHmgy4bZ/RHiOidx75S4nv04q3Fq5er
mcwKxyuBMHZpoWIcwUFmuRsUJQACacHv16UO74v3x/vk/dqNy9pzNbsBhvKpqSZa
S4xjX5/H3v0FmLytGABcoTpDbFJhvUQv3KxWJ5XAM99dkHHLtitwmA0II/G+dGDw
fnnfvP9SRr72vDfAYEdPgbKNM3XpyhXZc+KczPhsn5rkEIMEsCdOPIFw9vsLJWb7
+59+kYRFWyR0PsT5As8BQifeL++bP/M5+Dx8LruRrT3/dQ+GuqBU8t4Igh1Hz0om
lDTu+2Ga4uZYTGPC562XI2dLdyUcP3deMcQoSTxNvH+luOJ5+Fx8PjtQXNLmoe71
CIbfgHqBjuqz8SvMNa4cTlaYps1byplkrvYRWWth+pXtXthw8JT6nLWKwGBUQPVn
43PyeX8taaYe1eblN9cLGBqCckqsXuypM9fvU2KVE+XMxFIPCJqzTqat/dwp79C0
dZ9L0FzP6g9lUZhm3vK5j1+rU+Ro81StwUCbu6jYOvjlkhTsPiLRmgJocXIiyVBu
DTHQE87/dNE5fzJMPts+vsErwKBLCqX44nk4D5wPwyjS5qvagaEmKMn4pAdOf6Ps
84rs59x74/K3KIePK2PbkTMyMmtdlW8XpVkgnAfOB+fFbiRp81ctwFAftEl/MsYA
lu46Urx/ujpxZGTQ3HWy9+TXFYo4zfhM2y68DBD61sF54fxwngxjkzaPPg2GZkYl
kSt5ElzFakuooHav2+9lxAfKHF//+HOxGzrKCwFh0fwUnCc7yXfUbGeVmUDob/Qg
7j7+lcQv2qq8gpWZrEAojVw5lRmfHTwJ62Kd1yiTpRHnifNFJ5qdB7O/r4HB32gy
rtp33ObTd8NqDIZH8fCZbysFBt5T6oqdSgn1ZkCEa0E0zp+dCervK2AI1u+Y+QF5
2w5f4z6usEcP14iFBfHTxctS2UFzjq7qqAUbvRYMRvc25/GXknpEsLeDIVS/0wsw
k2Zv3O+SyVgecSXTX+CusXDbFzJyzjqvVCbtTVBaG5zPCyXNz1BvBUOxRGACCJND
QjW/vDuI4pz6wrLdR90GBk5sLEzUcC/yPZStR6xX8/pDyWhosLeBwd8IhClr97gV
CLpJGQyTkIqoO8e2I2dtvoe8TT4DCM6vHSD8vQUM/Y0eRXdLBHtvnauOpnKVSRDj
BCrUvWCTT0kIuy2jf1WDoYk2n3IROQS6jmCW/W2BsvfthZ/F3ePE1z8ADOvLjI56
IyA435x3A66bVBUY6BE7pt+FbjWYmRtAF7Sd/95tg/cf6APKpD0geN8Go/NYZTyV
FQXCzaBC/Q5oB1fGq+gKGC64wawsbTBFjQkyETkbfQYMureS828YhRp/PAaG4qDT
7hNf2bKLcz2RILIeIv28mDU2Hjpty3vI8x3pwHnn/O8+cc4+uOURMHQojjV896Ny
mXpiNakA1ZzP5GDRt6aB4TKyj1g3EWLidmeW1CQfyA/D6GA2GOrr+Qj0hulBJ0/t
j2TU5Su/ipmDrm5GNX0JDPr8kB8GL2WRq/qDK0C4iU47/ZsYLPLkCqJyx6IVT4xP
kH3kS74Ho4e2oGQQb6HGN7eDoaf+DQeLvlH7lMVDSabMTqIYtIvxmza+/uEn5Zkk
AH0JDJZcW2DLbivt6W4wsDzsuO7CZUZORRJTKkrMdVyMmkd9rDtwQiav2VPhnAZn
Bj1887ccUok0nijGcWeCDPljcEgdd7a8z1kwpOtXLkBswNMKFsPWLEQ5g7oIegu5
Yv1nrbE3qUwZ+5GGNgbJNCPnrFUWjS/4IcifgpIxnHR3gYH1gRdtnrrzSN7c7PEa
BDJh9ob96mfdbcx7CMOKLfrugumAoJdv8c4vlZcyJHu910sJzg35ZDDDLzpT5+kM
GHL1MnemdYdVkdmlJ85a7QJX1KA9NSidUpfvVFlSxnvxyu0C80V+GZJicisLhhf1
KzEBlaFeixc9MJlBrX/zF6c9Bgiatmv2nVCV2MFeVIdRWmCP/LJLHH6xomBgVc9i
W8nbr6ongVlKY2UCRHS4EBSsq/TkKIKDZ/KavUqXUPcAseyNyiT5dumqb2ZxWdVa
ZYHhBT0iydpAs4Bgy43coJTEikgdPekla+N+qYqx+fBpm8XjpY4q8o38M0Q2X6gI
GHL0QthMk6QCVxTb53CVLdl5RLmb+T0VEb3cLipaS1HZwWqtWRv2KVBW9P7NBEOm
kg5XjKV7LoHhn7oFweLQcBNiD1bNf7Bo+1X/wf5T3yDhdYsChasTyodOoGPq4mWp
qsG09ngvdFaRf3uuBrIuavx1GgzJtpRyWwVSWPYGc8AAh07hkaJrVtkU7MXU2C2u
KpNgQh7a6VTlYL5FTuEhtW2EeokZSv6RjwYXXbKzYKgNOqmnk1tMdDvTXDx67vtS
J/XTPUfVhLoqds2MbJ48eVLi4+Nl//7y9ZNDuAd2jxupzNCqdVbpPDRUe5/U+Fwu
GIpD1Gx7Z14am830+er8T469f9g2ohZshgnn/AojeBjH+MmE7eLy5cuSkJAgt9xy
i7Rt21YKCgrK/DzbCekBvVFVXLBDPi4yuPRLC3GXZk4u0jN/WNNoVq6CLdC1Sb79
8edyayMzVu5SSSeuWBezTbQugoODMXM1FHXo0EGKiorKybG0OatG4hmqyllFPpKf
hqZji+zNTHsw3Ecc8JO70K3MDF3BCAblH7hQvn+Ajp48reCFEUyrk9YFnUNmjYCA
gGJALF26tNzP04O7dj+dVRuVs6qqdAfyVVdvNH47BEMf/ZNsX2dm4ooNDJtdchax
vwI9f87EByh1OOkr9h4zZhC7dWRlZcny5ctd+h92oWPdgw3YGz26dZCf5Kth9CkL
DFn8BBnEFroRJgak9Ni7q6nvrJtIKtjmVFmcRbMwEvEsZekmVTE2wVll0Zp0eAoQ
5Cf5aliAWY7AcDvorG4vO9Ngq9LNriC27Nv1OTPoS6BOMNKJgJGuQ7AftJn5DxUZ
BCh1CU/lhugNUgxl/mc1vl8Dhlf0TywwuQbCGHWkGK/oYINvpnqVl3xi1dLmDp35
1qvAQGjmbD2kLA1PbhXkr2G8UhoYIvTYPTNlPJHxzAopTsSWSuQ2Hvnqe+V5DCrD
66eDIb+kaVXlQCjOtfSwVUH+GvSoiNLAsE7fk7nKPJXfSDFf2W4s9PpxYkeUYbox
KYbxA68BA7aslGU7TLXYHOlq5K+hZnWdPRjuFO3shq1fnvFY+ruRyEjmNX79Q8Vr
Kddh22Chja0Jx7U1F3NLatJVPhicC5zj+YJf8pd81g0cjf/FYHhOD1cvxDkKVQEG
olUli8Dc3HnsbIUn+BQQn7HSlidp1NQDZq+1749U5ePYufPXANdTYCCfDTvWc0Yw
9NMdI0yGCJ9fNc0rrFp2DhmZveUgxP/FCk80+ykydEuJw+TZxV6kLxi3ChYGhXp4
vsO1pBeDddXPCIbxuguaJ614Q/EpAUHF8PNK5ijQUbX96Bnx1rEefa093UqI/CWf
Da7p8UYwrFE+9G+0KKU35Dfm2WxiWgm5hdc0t6o2g/UNzGT25AK0aIok+a2NNToY
2Ir2gO5sqqotosw4A72IQDIruarjUIqkh03M8JLOJ/K/JsHwP6Kd+8hmmaFeWIHM
ZFOmflPB5MkupRzg4dODkVlbz0fPKpHkt55TRBzop8CoQaeMt5ajW7XgE500KVC6
2HqnOg16IlXnGA/FKcjn/B1fGG/hKYKhtacile6SEnRBU5/YcOhUtQEDYzR0q1s8
1KS0lAhma4Khq/4bG26Gzff+noh6eR3zJFkca1aI2tNj/lZboa8ndAfy2a7BaleC
wU9PIGFkz1caZBqTWNJW7JLzP1/0eTB884PW8d4DoQDymfw2ND/xIxiC9Hw9OkB8
qcGVvm1wr00u2G7fKNNHLYsvPeJ3IJ/J70tXpWoQwRDFn2jHM2nE18Cg+yQoIaau
3Wvffd3nxvc4ZkkF8EzmA/lMfhv8N1EEQ4JKGMGbtOUjfRAMxX0cYHq6u4NsVQz2
VjC7jVCkVs1m6IaTQDAk6tlDTImqyvMfK6tUcrtYvueYz4OB252uJJuZOkB+GyrQ
EsuVDPynq2dNbzCl1M6daKdrtzroDstQRGRmx1pHksGhzkAnD4NFk9bvlxi8ZiDf
YPqmgxKNn92V/EJw2Zfkq/fQrdXVMne9X4M7jyGoqnFekw5mJSU70hkcWhMRoE9w
iGj7tyIkMGOJJE9eJk8/0U+6B02VBCRyVhYQDJhMga2bhCIZiyETZxpAN3XFjhJm
EO/L3uzSjxWOhriz4nT6KBS9WgFU/q06SAdmf5kVs3BkTTj0M0SCpqII9sG735Eu
H2fIiOi58ocaL8k7H6XKmNV7ygRDeVYJi2HSUQwaCGC1bBchcTANydyxSEyJHrdA
7qrZXLr6T5T4T3dKGsAyBT2d0nAv42ExxKIySG1nkBzZ276UZOQsxE5bIdOWAhSz
VskIiNdVnx/3eTCwCFmVFJiwNTvyMzj0QFJcTwLTX38zXE18VEq+1Pqv16RH0DQZ
DUdPVO5VvaLEigWl4lT4OOxJ9oDhgylm4noZYHDnbvFy2x9ek5BPVkssVng0VviI
zAJp8OgH8kHYTEnCPY2fuVKav+wvAz/OlD4DJ4hl6qcShWvPQ2i7exervPZerASM
XyTPPe0nTzb2k9iCHZKA61SHsDfrI82IWTjyQDqMTRAMmRDZnXuMwQRvF+u4hVIb
jOtrmS0JEDFkrAVM5WodjwuTkWFA3FQAaFTEDBk2IV8xXgcEw6bp+FsaHi4enxsP
wAwdNV3urPmmBE5dLjH4f9YDToOLOWfXUYmB2KfEiMYWddvNr0ksJEDzlwKkFu7h
4+Q8ycS93n5zawmeuUom7jgifiMmS+OXhssYZPGwrtHQscR3vZL6OZy5nolNOIxa
EgyTweSB/pNkHER18pRPFSO4YgkGK5iViwtGxM6TQcMnSdTsNRKL95PB0Pvu7ij/
eGIAwLBdYrCKo/FZAmc+gNPg3s5S/4H3JWn5LgmyzpE6f3pLgqavxJawQ+KRotat
W4L855lB0r7fOBlLyQDw3F27vYzHdTu9GyN/+t2r8gEYPyJytvz59nYAw2oZi+v6
h8+QJm+FyliCEbmFUwDkahHRhAQMcrNlYYtafnlN1NJhPoMOhrc7RcvQmLkyNHCq
1PnvN+RdvzQwfafkYDV2ejtCat7USu64pY089EB3icCKHIe09Z7QKxq/HCAp2Oen
YsVHgjkTseKDI2bJn37fWho1HiQZWw+Lf8gMqVurvYQCBNwmrEy7S1kof/ptK2nZ
IUqSID3SkPF85x/fkPBJy6QrpBTB0A8SxW/EJPVzAiROFjrADAVAXmofqfQZm0m8
QeUKVIuIJivc3GhZOMpncJjpRCVjEpS8PoPSVQOuVPztzzXfkNbvxsqEzQclHYyv
BfH9QotACUtfIncBKP9pGSSJWJHRs1ZL79CZsurwGWkMC+SRx/tJPhxCLV4aIbVv
fl26Dp8sk6EtDw2eJvXufFvCgHyar9xW0nCj9W5rJy3aRcpYfH8aJuEubCVB4/Pl
g/4pctvvX5VukFZDkhfIC60CpR9A6h+XLW3x+VYALsGg51Fu/qLIJxheXokA0/zd
2UTMUaaTwxxI/sMUrMwBUNwoVqaAUfdgFXPCZ+w9Lr0HjJdbf/uKdBs5VWbvPiaN
/tFf/nb/+2pVjsGJsgGQAsOGZUptgKRB/fflnXes0gB/f+B/u0goTKbUjQdkOABz
9x0d8Pta5b+Ih46QAmWyLraOZq+HyhhIpgxsL3fd+pYETlgkA4ZkyG2QBp2gSM76
/IRkolQ/AspVEkzgQGsWJEOEDQxaFfbczQd8AgxpK3eqczYdjZPf2s7Riso1NwfS
YXY0wTANGn/XHokyChM7HWCod1tbaY4VOAWrukffZLkTjPaDYjkdYrp5swD5G7YK
6gejoWOEJi2QO2q2kXv/3EkisEo7DxinxP9rneNkNJS8cZAgIyNnKUaPghIYnQ/J
gCqjxMmfSp0/tpEXIXESsc1kACT1oBuMBBgGYysgAPuOminho+dJp35jxYK/j4ZJ
yms1axdebPby/pPhWDH7jAp3DBYQDZmxCkcEOHaYTYeUdEddZnnZ0aXWTXCbmIJq
5w4dLRII5XAivIJ1b31T/vX8UEnH/v/h0Ezs9+0gBXZJwaEiafz4AHmeDMQ1rPhs
LFZsw/u7SpPWIUoRHAdH1WOP9JZBYxeo7SAJnwuFeL/tplelF3QH+hjyIHGiYuZI
TYDm2SbDZSy8nxm48btueV0GJ+bIIOgKv6vxotqCPsT28EjDHvCF7JEcbFu9P0iU
1u/HK2siKvdqQ5DzP3m/A2oWFh234hEo9mFlWGnDdjDKOrdsEWXVTZRaUcXVlQgN
n5p7IFCbvGSbPPpwb3niqY+Uxu6fkicP1u8mHw3PlI+HZijR/jGUP+VA4lE5WOXD
UxfLyKkrlD4QBYCEUivGK689GuAIAoPr1m4rnQalyUTsiwMGpcpTz/rJQw17SUNY
HAGQBnFwJrXvm4Rr50skHqTjoPESNGOlhGPiXmoTIm0A1nbvxcmbPRNh7m5Q19fv
n+7cc17Wm6HUSCW9jVrxMF8dVX+lY+FVNjWxvIoqh7WWnNAYgIBxAu41EfhbCDR/
/k05j8CcroFT5Olmw+T9kVMUg3Wtl6/8DIFANLIXQeZCrfMZnVhgWjpeh8FhxK2F
fosgXDt6UaH6H0qQgQnZ8D8USiI9k4u2KEZz5fPvNG3pFrfi7zH4ntEwVa3oI6nv
q7YmYht9Iqx9FNXko+auL/bOMh/yeCmHs+1EG57KuqjLq7V0ugqbTIvR/P+cdO7z
ZAglhS1e4cDjBaZkQZQ/8XAPad42Qu3x6exSb5kpHfwmqK1FBZu0ABVf45dtL+G0
Kqbckh7NcStt+sdoSDH1eQOQuT/6gmS4Yii1s2oM49GN9m2OeKgaHXMVzVV1pgq7
8v0ZcsuPTs6EZfLM0x9JHZiJQyD+lxw8LS/+20/e7DVGrfyKxOSTAcDkSQUyCDGO
8NE5EgtXNR1klBARbAOICf3p4iXxhUG7X+/XoBcip8Equ2SX8MtGYRVNjXO2P4Op
nVsY9EqFIjhw2ETlnGraepRkYTXXux36wsBUSWSsQ1NuLGAktyZuI0aQUXwypkGP
JrcI/p4GgHV5P0HqIZg2amyuPPiXd6VJy5Fa+HeT0pp9peiGUiDKkNSi0vnA9LmQ
qGV9zozOLab2dCIYxoORH8fNk74Bk+EreEUGICrZ5IWhkAxjlWRQB35Dq54NmzsF
yuEYBq60YBfvJx1m5jz4EyZggsbgetQTxmF7GobAWcNH+kj29iPyDyi4d8IxNgSx
CyqyBNeZ7y+Ir4z5qD43OpcICFaS20dhK5JW70pPJ1O7vUXioVKwUnsCCBTjf3+s
t8RnrZGmLwyTl5AvkQDJkE7zM2Mx/BLtpTaio08ithFN6wB6CfWBWfmb5eEH3pM7
4MGsf19XCUJ0MwMmbgDMzLp3dZRJ2DIa/bO/1IMTi2BIgDVDzXz7Md8JWFGRtO8T
ST2Mz2Ho4Yg2y673dnCl25upfSAjtG2i55B0iWPEE79PRtZUi2Yj5Il/D5I4gGE+
xOHj/9dH7v1LZ+kFqVEPPowXXh4hMVjh85C38NorgVIbq74H/BsP/a27PPxQL5mA
bSIoKkvuhDMsDYptY+gk9GjSDKUCqpqD7j/hM2Cg6Z9WivnIvZ7vsYeVrnBOcLFT
nKt9IE3rEBsOVE6EMtQNLuworHTud5kbDkiXrgnyyD8HqFhHXNoSuR1BrGZvhEsW
lMuXAZS60CnCsFImA9H31nkbkdAPZRocU90+SJJbb3oF0mGZRMIEvQNgyABoXnx2
iIpwDoWCSte2LybJ0uyzVxCtmojnz/q2xw64rkQzXe0Qa1rvaFoTPDqgE5jP1DRq
+kxu+RAR0L8/1k/SEcEcFv6J1AIY3kX8YfoeMBy6BHMdGLdIRLziTmwPrTpaJb0Q
rYMR+q75m1YyHD4KC9zhBAPB1gxey7trdxB/ACtOA0Nl2gtWxWAT9FilIG+8pj4k
RJmcW5W5zOBWqJPu6Yr0jjatqzzBMB3Mb/tWuHyM6COlA8EwGCL//vu6qcypSLxP
hg/Gqs7af1K6IyZy3z3vSRzE/TiApx48nF3h2JqKAFUoUvBqIWwejR5QVng9a8Fd
Te9c0xeHqZyLYQBDfIGtxb8j9643j8V6hlMpBUPkCTvn8zPUJ5w546siXeUrdN6E
M3F2Ki9TEKX895MD5NWusYr5qXA69UX0se4d7SUWpmQk8hjr3PqG+CNpZT5W+WMP
dpdXO8eouEYCrvFXmI3vQVosWLdXWjYdLk8+M0RSsNUEZyyVxxsNhBm6UXoCLM/g
b6Gz16goKJWxfae+9jkw8LxOMtDiIAucK93ZhuSVOW/C6ZNoFAjytsjYFfsw8dsU
M+yTXq14P2axlsAKN/Ow9KUqTS0aPgR6L0cgYaWfdbZyNdPtTPHepkucPPr4B8hn
HKw8keqzZCyyodr1ToLCOUAaPtRTRiFewlQ5q5Yex/vhayKsleiFNj+EL2dK83Q8
d0Qpi0+iuRq8dfokGqfPqIqEiP5k9Q4JiEqUwIkLFHONexSjlGkL18rwSQthTn4u
KfkbJGnNPqS/bVIBJYKHAIhX+ZQblIOJDqX4FbuK3dF0PNFXwO+yAjCJa2B+fnYY
cYjdCgjFUinv2tXDsDsP+vTVoeIQbjjvqrJnVJV7ep1FJbDsk9DEVHnon09B6QtF
QiyYCklBKRGWs0nmoiPr042fk49C4yR25gJp3qKFtO7pB0fRQUlZvR8icLMCQfTC
rYgtHATjt0raukMo7kBOw/K9WtR0t2Su2y+JeQDSyn0yY/kWGWpJlKCp+TZpVE7H
OLOOKPLEYHY3dYPKtElwx+l15Z5rqYMhIGqMPPp8c0nbdlaSlu2U2ZAUcdlrkPt4
QDKycqQBgBKanoUcyjHS5u1O8vRrnZCveELavNNdrfj45fuUdOk9PFSmLF4t/f1D
JDAxXQZaU2TsqgOSOHWedB88QvoMGylDLKOlc/ce8tY7neXVTl2hWJZeu2HVzpnk
uQ6+PmxdZCsepXTXuZblnngbuwQevvS5iAW8KiGTsxFr2IbklUfk3vsflICMbBkc
EiV/vvd+icnbKAnpk+RfjZ+R51q3k6QVe6Rlp+4yKW+lWKcvFGtyqtSsdYcMTZku
7d7tItakNHnkiaclYFIermGVJp162Ur6Zi6WVm3awgS1SPsuPSRcdYDdXGqBDrep
r85f8Hkw8MzP0Ar6e9x54m25Z2FbcqgDHJLMxWulQcOHpY/fMHm86avyYXC4PNn8
DZm3bos0eOwJ1FwgJS0zG2B4Vpq274J8xYOSnLNaWrVsJQ8/+g9p0KCBNOnYU1IL
z8r0RSvknvvrS0zqZGnTo58Ej06Sl97pLWPXHJaJW09Jqzc7yPOtXpe+4XFKKbUH
g0W190HNxDHfr5nQB8W8qya+u8/C1ilXd39SGQszZEElLNst8VOzJSAyHtnPjaRT
rw/l/cEBYkkYIy26figJ0+dLvfseUHv79F3nkJHURV5u0VIGJ0+XlBV7pe69f4U1
kSMvtukgQ9NzFLDC0mfLzTffjJB0hDz+fFMZGDFamr/XV5KgZyRgW+gTkSQt3mwn
H8cmQRHdci0QEODyJfezM2MLDn53dasgn8gvQ2pbbnm8dgYMjXTLgqewseRdD53G
Lt4u/hnzpV1/f/nAkiKjZq2QDgDEs81aSjB+Dpm9SvySZ6ncghh+NjNXmnboLr2t
6bAGYLLOgS8gv1ApkLYVjmujRqJHeLKMwoHj/hm5MnJ6gYz6ZLmyVFTmFLamQeNm
y0dJs0pYL/pRBZ8dPCXVbah+DXnOV2RzLsinE1f9Chc1PlYaDKT04lw9lLuHGKQD
V33Cp3uVlIjBz7FLkQwLBsfCt0AQxC/bfTUFDoAYixUet9RmSsZo1oBKVdMfBg8x
GpYE/QSxS7ZrKXAlazbjC3ahjnNHCYlAhbHwyBmproMBJmedTORPQcm2BOnO8NlZ
MNShQ5JXZa9jZsqUVCY3XtN0y3FGlPsrillXuenQaanOg15UZzKjyRfyh3zSxnGN
f24DA6mnfnX2cI408VhkV5tzFOw+ItV9ME0tAQ66sjrn6CcC2vXY7uksj10Bw02g
hfo36Mf6ViUQuDVMR5ziehl528ouwCU/7I53Wqjxze1gINWn6at7xyat3l1l7YUp
Dpk9XB06tDg7eNi6I72BfCA/DD0pijR+1TALDCVC3KfhEKG7tCp6R3KFHDz9jVxP
g1tFotoqNlyTq0A+kB9lhajNAAMpSf/G3Se+0jq3eFZPMFQEXVcjF0lARkUyUisj
JB8MI6kifK0oGG4GFerfvGrfcVvs3QMKJbcH1b+wmp5MU97g2Vs6GDjfnHfOv2EU
avzxGBh0/eGYHv3I88ApuSoSCamw9+TXcr0OpsTFLdqileCtV/NuqDE/5qqe4C4w
kJrokU3uZzyf2ixA6MclM0njeh+s2B4Otzvn21AZ9avGjxpVBQZSf/1uePLsNJh6
ZgCCh3IweudLBTFmjY04dIVp8gbHkmh8qFHVYCD5G/3ozCNwJyD0vtBldTa5nsb3
6A/JHpGG4e8OProLDKRgIyDcKSEitZbCdhNwY9hGsLt46E4wkEL1O6QI454W4iDD
11WpsHjnlzfYfu0IdSf/3A2GEhKC3jDdyqhou/xIrV3utxd+vsF6kySCmWAooUPw
ZBjawWSqq8cT6PEHHvN3Y4jbdQRPgUG3Moo9QywDp8vU1Xw+Hlt46psfbrDfNi67
w2qoCjCQmoGKsyzYOkYPbjnjraS+wfy/G0ONo9p81vBVMOieyk36E9GNzDCrxVBV
7DAGwQ6vh4tuwMA2f/XN5pUnwKC3JE6y97EzIyfEgXKpJ8/cMCfVvNX0BJ88BQad
OoqWD6F7LJmlpFcWW+y2CG4p1/Eo0ubLY/zxNBhIDUUr3dMHq4OZ1s24vL51MF9h
ZTU4TaaCI0ebpxrVHQx6tVYvo3JJE5TFoZlau+LhKKk3FIteT0piLymj6qk6gkGn
uqBUUHHEhQWi21EbSH3i+Lnz1wsILmnzULcq+VHVYNCJp+FkG2eHodmLl69cD0DI
1p6/yvngLWDQqSko/zqRBvna83rN/HsbGIzOqvlGD2Y18iDON9t5VN3AYKzzHAfy
9UraE9pzNPLm+fZ2MBjL+zpqotVXtMrz2v12FCfL226AwXX6K6gvaJZoZ2R40Tij
3Vdf7T59am59EQxGqiW2Q1rDQGtBnq7HP6V9b5h2H7V8eT59HQylbSc8Yoc9kXkI
1yrQftHO7azE+E67zirtun2076lTneavuoGhNLoVdI+mvHH1dhPbYfDMFIoCJYAS
tdco7X0/7XOttf+7R7tOtZ6r/wfNB9sCumRpVAAAAABJRU5ErkJggg==

------------Y47EGPtdbWNKttFrOftBHR
Content-Disposition: inline; filename=hash_just_right.png
Content-Type: image/png; name=hash_just_right.png
Content-Location: http://chipmunk-physics.net/release/ChipmunkLatest-Docs/images/hash_just_right.png
Content-Transfer-Encoding: Base64

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
AElFTkSuQmCC

------------Y47EGPtdbWNKttFrOftBHR
Content-Disposition: inline; filename=hash_too_small.png
Content-Type: image/png; name=hash_too_small.png
Content-Location: http://chipmunk-physics.net/release/ChipmunkLatest-Docs/images/hash_too_small.png
Content-Transfer-Encoding: Base64

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

------------Y47EGPtdbWNKttFrOftBHR
Content-Disposition: inline; filename=hash_too_big.png
Content-Type: image/png; name=hash_too_big.png
Content-Location: http://chipmunk-physics.net/release/ChipmunkLatest-Docs/images/hash_too_big.png
Content-Transfer-Encoding: Base64

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
rkJggg==

------------Y47EGPtdbWNKttFrOftBHR
Content-Disposition: inline; filename="ZgJJZTS0aMM&hl=en_US&fs=1.swf"
Content-Type: application/x-shockwave-flash; name="ZgJJZTS0aMM&hl=en_US&fs=1.swf"
Content-Location: http://www.youtube.com/v/ZgJJZTS0aMM&hl=en_US&fs=1?rel=0
Content-Transfer-Encoding: Base64

Q1dTCLoHAAB42oVVW3PTRhQ+luVIdi6AS3HTOiFpgU4ZYjlXEqalZBzIOI0vYwMF
XjSytJZFdENam+gXlKc8eqYP7W/pEz+kfyQ9u6vEBkrrh9We+7fn27M+hZlHAMW/
AG5m4OAa4O/n7N8ZgPEugDOMXIABpeEDTXM2Kwl1PLtiBp42crRX9tHRq6fdqtFo
aIM3FukbQ5dWXoc2LI0XAAhGEq9HLItYqLkL0CenIcBedWt7q3pvr7p5v7qLn/Xd
6t69vfWd3SpTbm/s3EfvWazK4n39WRfFEkAYBT2j5ya6G9g2sXTHB1gXppFjkUB3
LIApSGiaA4iJb1EvFK7bKL/tX54nnjpOQjU09RxfM8N4bdR3zRebzV9PK8x/afw9
Bp4APGsavySHOwekXa33j+wXxztbxxsbTftNS683T14e1tBVwWPGopwKELEmVHHf
wAO4RuI6MdW9wBq65H9gfOTNIA13n7d6L1NIyBmZJsccOKE39E/WwkESO2Zc8QnV
sDwxYqLVUuOxQUlM1w4CM9ZgCWrS+fn5+zy0kW24sYBrW9fbhnli2CSumHYy7Lbh
fEHJobn97nnmDqQ63XaRDJdxQgOahAQ8A/lwA8OquU4IJl8iguUeeyFNGsHIIdxy
uTtGXxKBYVk1w3V7WBTJRn7J69gIHexf3zXiAZBTSiIfSz1ON3Ufv33DJGCMDMdl
EWBE9tAjPo2h74OFJ4yCBIY+g8PrIQ1eMCITFKy5JOIQLHDi9rTI2qtBHLoOFb3l
a/wApngCRgc4vkVOW33gjCBaWk8VeIUgHvYQh+PboDOaNA0umIX9bpfQdhSET1zD
jmEsgQrlYvEPCf7MMiFT5qozlc1idhGX35Ca1lgGGVSpiUKmJITsGc5ZBuZWQbS8
nh1fBVVWGJ/4kdgnx7PNdH7Eq6mwjKryCFNIJaYWRvVsjqXJYhps4HuYWPJNthbq
xwzdIvCYWW6Z45Z5vi40mfksRSytQounuFIe50DJoqo5EaUPxcyHInARgcoT6FfL
nYcCsAKyxF1qQs8cWfp/gaR2Sq3JMa6lyH6AHbhsgyxMndJHmuInmi8mybDp13Mw
lfrLy9TzU3273nw45XODcZYtjfOglgQ3F3q2ftVBq8xPJ4sGoJzjDOfUxXqR974A
qeLrelHILHRRePJIKY2c4Y4z6jfCcSXDypY/LbvEyioc1PJnrOrnIN/sXHB3iG55
fi1WcFfgWBQFn5Vzm1W/DfiSy4qcn76LIsdqhwf8LuGssyh1ErXCo9T/iJrCJSj6
Nm3l5RVDt9m0Zd8dok2eZat6i+8LfL98KGiReBKsmOWhsqTKjPAr4oSSnBGX7PZP
JfxnPMDtu2UcvsbT/W5Nb+zXm0AHTnzxNPKHkM8vG9pSOs+KyKVKHGy2U4JtNqpw
V+ihm8SUeFAeF9hfljmMHJrgIMwD4OMYvD0IeFoMw2cf/gG7kK/C

------------Y47EGPtdbWNKttFrOftBHR--
